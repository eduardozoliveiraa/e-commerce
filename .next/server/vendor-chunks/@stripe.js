"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AffirmMessageElement: () => (/* binding */ AffirmMessageElement),\n/* harmony export */   AfterpayClearpayMessageElement: () => (/* binding */ AfterpayClearpayMessageElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   CartElement: () => (/* binding */ CartElement),\n/* harmony export */   CustomCheckoutProvider: () => (/* binding */ CustomCheckoutProvider),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EmbeddedCheckout: () => (/* binding */ EmbeddedCheckout),\n/* harmony export */   EmbeddedCheckoutProvider: () => (/* binding */ EmbeddedCheckoutProvider),\n/* harmony export */   EpsBankElement: () => (/* binding */ EpsBankElement),\n/* harmony export */   ExpressCheckoutElement: () => (/* binding */ ExpressCheckoutElement),\n/* harmony export */   FpxBankElement: () => (/* binding */ FpxBankElement),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IdealBankElement: () => (/* binding */ IdealBankElement),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   P24BankElement: () => (/* binding */ P24BankElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   useCartElement: () => (/* binding */ useCartElement),\n/* harmony export */   useCartElementState: () => (/* binding */ useCartElementState),\n/* harmony export */   useCustomCheckout: () => (/* binding */ useCustomCheckout),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar usePrevious = function usePrevious(value) {\n    var ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n};\nvar isUnknownObject = function isUnknownObject(raw) {\n    return raw !== null && _typeof(raw) === \"object\";\n};\nvar isPromise = function isPromise(raw) {\n    return isUnknownObject(raw) && typeof raw.then === \"function\";\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\nvar isStripe = function isStripe(raw) {\n    return isUnknownObject(raw) && typeof raw.elements === \"function\" && typeof raw.createToken === \"function\" && typeof raw.createPaymentMethod === \"function\" && typeof raw.confirmCardPayment === \"function\";\n};\nvar PLAIN_OBJECT_STR = \"[object Object]\";\nvar isEqual = function isEqual(left, right) {\n    if (!isUnknownObject(left) || !isUnknownObject(right)) {\n        return left === right;\n    }\n    var leftArray = Array.isArray(left);\n    var rightArray = Array.isArray(right);\n    if (leftArray !== rightArray) return false;\n    var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n    var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n    if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n    // fallback to reference check.\n    if (!leftPlainObject && !leftArray) return left === right;\n    var leftKeys = Object.keys(left);\n    var rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) return false;\n    var keySet = {};\n    for(var i = 0; i < leftKeys.length; i += 1){\n        keySet[leftKeys[i]] = true;\n    }\n    for(var _i = 0; _i < rightKeys.length; _i += 1){\n        keySet[rightKeys[_i]] = true;\n    }\n    var allKeys = Object.keys(keySet);\n    if (allKeys.length !== leftKeys.length) {\n        return false;\n    }\n    var l = left;\n    var r = right;\n    var pred = function pred(key) {\n        return isEqual(l[key], r[key]);\n    };\n    return allKeys.every(pred);\n};\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n    if (!isUnknownObject(options)) {\n        return null;\n    }\n    return Object.keys(options).reduce(function(newOptions, key) {\n        var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n        if (immutableKeys.includes(key)) {\n            if (isUpdated) {\n                console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n            }\n            return newOptions;\n        }\n        if (!isUpdated) {\n            return newOptions;\n        }\n        return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n    }, null);\n};\nvar INVALID_STRIPE_ERROR$2 = \"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\"; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\nvar validateStripe = function validateStripe(maybeStripe) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n    if (maybeStripe === null || isStripe(maybeStripe)) {\n        return maybeStripe;\n    }\n    throw new Error(errorMsg);\n};\nvar parseStripeProp = function parseStripeProp(raw) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n    if (isPromise(raw)) {\n        return {\n            tag: \"async\",\n            stripePromise: Promise.resolve(raw).then(function(result) {\n                return validateStripe(result, errorMsg);\n            })\n        };\n    }\n    var stripe = validateStripe(raw, errorMsg);\n    if (stripe === null) {\n        return {\n            tag: \"empty\"\n        };\n    }\n    return {\n        tag: \"sync\",\n        stripe: stripe\n    };\n};\nvar registerWithStripeJs = function registerWithStripeJs(stripe) {\n    if (!stripe || !stripe._registerWrapper || !stripe.registerAppInfo) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"react-stripe-js\",\n        version: \"2.6.2\"\n    });\n    stripe.registerAppInfo({\n        name: \"react-stripe-js\",\n        version: \"2.6.2\",\n        url: \"https://stripe.com/docs/stripe-js/react\"\n    });\n};\nvar ElementsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nElementsContext.displayName = \"ElementsContext\";\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\nvar CartElementContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCartElementContext.displayName = \"CartElementContext\";\nvar parseCartElementContext = function parseCartElementContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://stripe.com/docs/stripe-js/react#elements-provider\n */ var Elements = function Elements(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), cart = _React$useState2[0], setCart = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), cartState = _React$useState4[0], setCartState = _React$useState4[1]; // For a sync stripe instance, initialize into context\n    var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            elements: parsed.tag === \"sync\" ? parsed.stripe.elements(options) : null\n        };\n    }), _React$useState6 = _slicedToArray(_React$useState5, 2), ctx = _React$useState6[0], setContext = _React$useState6[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        var safeSetContext = function safeSetContext(stripe) {\n            setContext(function(ctx) {\n                // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n                if (ctx.stripe) return ctx;\n                return {\n                    stripe: stripe,\n                    elements: stripe.elements(options)\n                };\n            });\n        }; // For an async stripePromise, store it in context once resolved\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted) {\n                    // Only update Elements context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    safeSetContext(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !ctx.stripe) {\n            // Or, handle a sync stripe instance going from null -> populated\n            safeSetContext(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (!ctx.elements) {\n            return;\n        }\n        var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n            \"clientSecret\",\n            \"fonts\"\n        ]);\n        if (updates) {\n            ctx.elements.update(updates);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.elements\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ElementsContext.Provider, {\n        value: ctx\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CartElementContext.Provider, {\n        value: {\n            cart: cart,\n            setCart: setCart,\n            cartState: cartState,\n            setCartState: setCartState\n        }\n    }, children));\n};\nElements.propTypes = {\n    stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n    return parseElementsContext(ctx, useCaseMessage);\n};\nvar DUMMY_CART_ELEMENT_CONTEXT = {\n    cart: null,\n    cartState: null,\n    setCart: function setCart() {},\n    setCartState: function setCartState() {}\n};\nvar useCartElementContextWithUseCase = function useCartElementContextWithUseCase(useCaseMessage) {\n    var isInCustomCheckout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CartElementContext);\n    if (isInCustomCheckout) {\n        return DUMMY_CART_ELEMENT_CONTEXT;\n    }\n    return parseCartElementContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */ var useElements = function useElements() {\n    var _useElementsContextWi = useElementsContextWithUseCase(\"calls useElements()\"), elements = _useElementsContextWi.elements;\n    return elements;\n};\n/**\n * @docs https://stripe.com/docs/payments/checkout/cart-element\n */ var useCartElement = function useCartElement() {\n    var _useCartElementContex = useCartElementContextWithUseCase(\"calls useCartElement()\"), cart = _useCartElementContex.cart;\n    return cart;\n};\n/**\n * @docs https://stripe.com/docs/payments/checkout/cart-element\n */ var useCartElementState = function useCartElementState() {\n    var _useCartElementContex2 = useCartElementContextWithUseCase(\"calls useCartElementState()\"), cartState = _useCartElementContex2.cartState;\n    return cartState;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */ var ElementsConsumer = function ElementsConsumer(_ref2) {\n    var children = _ref2.children;\n    var ctx = useElementsContextWithUseCase(\"mounts <ElementsConsumer>\"); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n    return children(ctx);\n};\nElementsConsumer.propTypes = {\n    children: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired\n};\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n    var cbDefined = !!cb;\n    var cbRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cb); // In many integrations the callback prop changes on each render.\n    // Using a ref saves us from calling element.on/.off every render.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        cbRef.current = cb;\n    }, [\n        cb\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (!cbDefined || !element) {\n            return function() {};\n        }\n        var decoratedCb = function decoratedCb() {\n            if (cbRef.current) {\n                cbRef.current.apply(cbRef, arguments);\n            }\n        };\n        element.on(event, decoratedCb);\n        return function() {\n            element.off(event, decoratedCb);\n        };\n    }, [\n        cbDefined,\n        event,\n        element,\n        cbRef\n    ]);\n};\nvar _excluded = [\n    \"on\",\n    \"session\"\n];\nvar CustomCheckoutSdkContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCustomCheckoutSdkContext.displayName = \"CustomCheckoutSdkContext\";\nvar parseCustomCheckoutSdkContext = function parseCustomCheckoutSdkContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find CustomCheckoutProvider context; You need to wrap the part of your app that \".concat(useCase, \" in an <CustomCheckoutProvider> provider.\"));\n    }\n    return ctx;\n};\nvar CustomCheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCustomCheckoutContext.displayName = \"CustomCheckoutContext\";\nvar extractCustomCheckoutContextValue = function extractCustomCheckoutContextValue(customCheckoutSdk, sessionState) {\n    if (!customCheckoutSdk) {\n        return null;\n    }\n    customCheckoutSdk.on;\n    customCheckoutSdk.session;\n    var actions = _objectWithoutProperties(customCheckoutSdk, _excluded);\n    if (!sessionState) {\n        return _objectSpread2(_objectSpread2({}, actions), customCheckoutSdk.session());\n    }\n    return _objectSpread2(_objectSpread2({}, actions), sessionState);\n};\nvar INVALID_STRIPE_ERROR$1 = \"Invalid prop `stripe` supplied to `CustomCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar CustomCheckoutProvider = function CustomCheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR$1);\n    }, [\n        rawStripeProp\n    ]); // State used to trigger a re-render when sdk.session is updated\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), session = _React$useState2[0], setSession = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            customCheckoutSdk: null\n        };\n    }), _React$useState4 = _slicedToArray(_React$useState3, 2), ctx = _React$useState4[0], setContext = _React$useState4[1];\n    var safeSetContext = function safeSetContext(stripe, customCheckoutSdk) {\n        setContext(function(ctx) {\n            if (ctx.stripe && ctx.customCheckoutSdk) {\n                return ctx;\n            }\n            return {\n                stripe: stripe,\n                customCheckoutSdk: customCheckoutSdk\n            };\n        });\n    }; // Ref used to avoid calling initCustomCheckout multiple times when options changes\n    var initCustomCheckoutCalledRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted && !initCustomCheckoutCalledRef.current) {\n                    // Only update context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    initCustomCheckoutCalledRef.current = true;\n                    stripe.initCustomCheckout(options).then(function(customCheckoutSdk) {\n                        if (customCheckoutSdk) {\n                            safeSetContext(stripe, customCheckoutSdk);\n                            customCheckoutSdk.on(\"change\", setSession);\n                        }\n                    });\n                }\n            });\n        } else if (parsed.tag === \"sync\" && parsed.stripe && !initCustomCheckoutCalledRef.current) {\n            initCustomCheckoutCalledRef.current = true;\n            parsed.stripe.initCustomCheckout(options).then(function(customCheckoutSdk) {\n                if (customCheckoutSdk) {\n                    safeSetContext(parsed.stripe, customCheckoutSdk);\n                    customCheckoutSdk.on(\"change\", setSession);\n                }\n            });\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options,\n        setSession\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on CustomCheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var _prevOptions$elements, _options$elementsOpti;\n        if (!ctx.customCheckoutSdk) {\n            return;\n        }\n        if (options.clientSecret && !isUnknownObject(prevOptions) && !isEqual(options.clientSecret, prevOptions.clientSecret)) {\n            console.warn(\"Unsupported prop change: options.client_secret is not a mutable property.\");\n        }\n        var previousAppearance = prevOptions === null || prevOptions === void 0 ? void 0 : (_prevOptions$elements = prevOptions.elementsOptions) === null || _prevOptions$elements === void 0 ? void 0 : _prevOptions$elements.appearance;\n        var currentAppearance = options === null || options === void 0 ? void 0 : (_options$elementsOpti = options.elementsOptions) === null || _options$elementsOpti === void 0 ? void 0 : _options$elementsOpti.appearance;\n        if (currentAppearance && !isEqual(currentAppearance, previousAppearance)) {\n            ctx.customCheckoutSdk.changeAppearance(currentAppearance);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.customCheckoutSdk\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    var customCheckoutContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return extractCustomCheckoutContextValue(ctx.customCheckoutSdk, session);\n    }, [\n        ctx.customCheckoutSdk,\n        session\n    ]);\n    if (!ctx.customCheckoutSdk) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomCheckoutSdkContext.Provider, {\n        value: ctx\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomCheckoutContext.Provider, {\n        value: customCheckoutContextValue\n    }, children));\n};\nCustomCheckoutProvider.propTypes = {\n    stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.shape({\n        clientSecret: prop_types__WEBPACK_IMPORTED_MODULE_1__.string.isRequired,\n        elementsOptions: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n    }).isRequired\n};\nvar useCustomCheckoutSdkContextWithUseCase = function useCustomCheckoutSdkContextWithUseCase(useCaseString) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CustomCheckoutSdkContext);\n    return parseCustomCheckoutSdkContext(ctx, useCaseString);\n};\nvar useElementsOrCustomCheckoutSdkContextWithUseCase = function useElementsOrCustomCheckoutSdkContextWithUseCase(useCaseString) {\n    var customCheckoutSdkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CustomCheckoutSdkContext);\n    var elementsContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n    if (customCheckoutSdkContext && elementsContext) {\n        throw new Error(\"You cannot wrap the part of your app that \".concat(useCaseString, \" in both <CustomCheckoutProvider> and <Elements> providers.\"));\n    }\n    if (customCheckoutSdkContext) {\n        return parseCustomCheckoutSdkContext(customCheckoutSdkContext, useCaseString);\n    }\n    return parseElementsContext(elementsContext, useCaseString);\n};\nvar useCustomCheckout = function useCustomCheckout() {\n    // ensure it's in CustomCheckoutProvider\n    useCustomCheckoutSdkContextWithUseCase(\"calls useCustomCheckout()\");\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CustomCheckoutContext);\n    if (!ctx) {\n        throw new Error(\"Could not find CustomCheckout Context; You need to wrap the part of your app that calls useCustomCheckout() in an <CustomCheckoutProvider> provider.\");\n    }\n    return ctx;\n};\nvar capitalized = function capitalized(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nvar createElementComponent = function createElementComponent(type, isServer) {\n    var displayName = \"\".concat(capitalized(type), \"Element\");\n    var ClientElement = function ClientElement(_ref) {\n        var id = _ref.id, className = _ref.className, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, onBlur = _ref.onBlur, onFocus = _ref.onFocus, onReady = _ref.onReady, onChange = _ref.onChange, onEscape = _ref.onEscape, onClick = _ref.onClick, onLoadError = _ref.onLoadError, onLoaderStart = _ref.onLoaderStart, onNetworksChange = _ref.onNetworksChange, onCheckout = _ref.onCheckout, onLineItemClick = _ref.onLineItemClick, onConfirm = _ref.onConfirm, onCancel = _ref.onCancel, onShippingAddressChange = _ref.onShippingAddressChange, onShippingRateChange = _ref.onShippingRateChange;\n        var ctx = useElementsOrCustomCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var elements = \"elements\" in ctx ? ctx.elements : null;\n        var customCheckoutSdk = \"customCheckoutSdk\" in ctx ? ctx.customCheckoutSdk : null;\n        var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), element = _React$useState2[0], setElement = _React$useState2[1];\n        var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n        var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n        var _useCartElementContex = useCartElementContextWithUseCase(\"mounts <\".concat(displayName, \">\"), \"customCheckoutSdk\" in ctx), setCart = _useCartElementContex.setCart, setCartState = _useCartElementContex.setCartState; // For every event where the merchant provides a callback, call element.on\n        // with that callback. If the merchant ever changes the callback, removes\n        // the old callback with element.off and then call element.on with the new one.\n        useAttachEvent(element, \"blur\", onBlur);\n        useAttachEvent(element, \"focus\", onFocus);\n        useAttachEvent(element, \"escape\", onEscape);\n        useAttachEvent(element, \"click\", onClick);\n        useAttachEvent(element, \"loaderror\", onLoadError);\n        useAttachEvent(element, \"loaderstart\", onLoaderStart);\n        useAttachEvent(element, \"networkschange\", onNetworksChange);\n        useAttachEvent(element, \"lineitemclick\", onLineItemClick);\n        useAttachEvent(element, \"confirm\", onConfirm);\n        useAttachEvent(element, \"cancel\", onCancel);\n        useAttachEvent(element, \"shippingaddresschange\", onShippingAddressChange);\n        useAttachEvent(element, \"shippingratechange\", onShippingRateChange);\n        var readyCallback;\n        if (type === \"cart\") {\n            readyCallback = function readyCallback(event) {\n                setCartState(event);\n                onReady && onReady(event);\n            };\n        } else if (onReady) {\n            if (type === \"expressCheckout\") {\n                // Passes through the event, which includes visible PM types\n                readyCallback = onReady;\n            } else {\n                // For other Elements, pass through the Element itself.\n                readyCallback = function readyCallback() {\n                    onReady(element);\n                };\n            }\n        }\n        useAttachEvent(element, \"ready\", readyCallback);\n        var changeCallback = type === \"cart\" ? function(event) {\n            setCartState(event);\n            onChange && onChange(event);\n        } : onChange;\n        useAttachEvent(element, \"change\", changeCallback);\n        var checkoutCallback = type === \"cart\" ? function(event) {\n            setCartState(event);\n            onCheckout && onCheckout(event);\n        } : onCheckout;\n        useAttachEvent(element, \"checkout\", checkoutCallback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n            if (elementRef.current === null && domNode.current !== null && (elements || customCheckoutSdk)) {\n                var newElement = null;\n                if (customCheckoutSdk) {\n                    newElement = customCheckoutSdk.createElement(type, options);\n                } else if (elements) {\n                    newElement = elements.create(type, options);\n                }\n                if (type === \"cart\" && setCart) {\n                    // we know that elements.create return value must be of type StripeCartElement if type is 'cart',\n                    // we need to cast because typescript is not able to infer which overloaded method is used based off param type\n                    setCart(newElement);\n                } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n                elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n                setElement(newElement);\n                if (newElement) {\n                    newElement.mount(domNode.current);\n                }\n            }\n        }, [\n            elements,\n            customCheckoutSdk,\n            options,\n            setCart\n        ]);\n        var prevOptions = usePrevious(options);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n            if (!elementRef.current) {\n                return;\n            }\n            var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n                \"paymentRequest\"\n            ]);\n            if (updates) {\n                elementRef.current.update(updates);\n            }\n        }, [\n            options,\n            prevOptions\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n            return function() {\n                if (elementRef.current && typeof elementRef.current.destroy === \"function\") {\n                    try {\n                        elementRef.current.destroy();\n                        elementRef.current = null;\n                    } catch (error) {}\n                }\n            };\n        }, []);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: id,\n            className: className,\n            ref: domNode\n        });\n    }; // Only render the Element wrapper in a server environment.\n    var ServerElement = function ServerElement(props) {\n        // Validate that we are in the right context by calling useElementsContextWithUseCase.\n        var ctx = useElementsOrCustomCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        useCartElementContextWithUseCase(\"mounts <\".concat(displayName, \">\"), \"customCheckoutSdk\" in ctx);\n        var id = props.id, className = props.className;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: id,\n            className: className\n        });\n    };\n    var Element = isServer ? ServerElement : ClientElement;\n    Element.propTypes = {\n        id: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n        className: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n        onChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onBlur: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onFocus: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onReady: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onEscape: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onClick: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLoaderStart: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onNetworksChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onCheckout: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLineItemClick: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onConfirm: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onCancel: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onShippingAddressChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onShippingRateChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n    };\n    Element.displayName = displayName;\n    Element.__elementType = type;\n    return Element;\n};\nvar isServer = \"undefined\" === \"undefined\";\nvar EmbeddedCheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nEmbeddedCheckoutContext.displayName = \"EmbeddedCheckoutProviderContext\";\nvar useEmbeddedCheckoutContext = function useEmbeddedCheckoutContext() {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EmbeddedCheckoutContext);\n    if (!ctx) {\n        throw new Error(\"<EmbeddedCheckout> must be used within <EmbeddedCheckoutProvider>\");\n    }\n    return ctx;\n};\nvar INVALID_STRIPE_ERROR = \"Invalid prop `stripe` supplied to `EmbeddedCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar EmbeddedCheckoutProvider = function EmbeddedCheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR);\n    }, [\n        rawStripeProp\n    ]);\n    var embeddedCheckoutPromise = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var loadedStripe = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        embeddedCheckout: null\n    }), _React$useState2 = _slicedToArray(_React$useState, 2), ctx = _React$useState2[0], setContext = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // Don't support any ctx updates once embeddedCheckout or stripe is set.\n        if (loadedStripe.current || embeddedCheckoutPromise.current) {\n            return;\n        }\n        var setStripeAndInitEmbeddedCheckout = function setStripeAndInitEmbeddedCheckout(stripe) {\n            if (loadedStripe.current || embeddedCheckoutPromise.current) return;\n            loadedStripe.current = stripe;\n            embeddedCheckoutPromise.current = loadedStripe.current.initEmbeddedCheckout(options).then(function(embeddedCheckout) {\n                setContext({\n                    embeddedCheckout: embeddedCheckout\n                });\n            });\n        }; // For an async stripePromise, store it once resolved\n        if (parsed.tag === \"async\" && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe) {\n                    setStripeAndInitEmbeddedCheckout(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n            // Or, handle a sync stripe instance going from null -> populated\n            setStripeAndInitEmbeddedCheckout(parsed.stripe);\n        }\n    }, [\n        parsed,\n        options,\n        ctx,\n        loadedStripe\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // cleanup on unmount\n        return function() {\n            // If embedded checkout is fully initialized, destroy it.\n            if (ctx.embeddedCheckout) {\n                embeddedCheckoutPromise.current = null;\n                ctx.embeddedCheckout.destroy();\n            } else if (embeddedCheckoutPromise.current) {\n                // If embedded checkout is still initializing, destroy it once\n                // it's done. This could be caused by unmounting very quickly\n                // after mounting.\n                embeddedCheckoutPromise.current.then(function() {\n                    embeddedCheckoutPromise.current = null;\n                    if (ctx.embeddedCheckout) {\n                        ctx.embeddedCheckout.destroy();\n                    }\n                });\n            }\n        };\n    }, [\n        ctx.embeddedCheckout\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(loadedStripe);\n    }, [\n        loadedStripe\n    ]); // Warn on changes to stripe prop.\n    // The stripe prop value can only go from null to non-null once and\n    // can't be changed after that.\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Warn on changes to options.\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevOptions == null) {\n            return;\n        }\n        if (options == null) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot unset options after setting them.\");\n            return;\n        }\n        if (options.clientSecret === undefined && options.fetchClientSecret === undefined) {\n            console.warn(\"Invalid props passed to EmbeddedCheckoutProvider: You must provide one of either `options.fetchClientSecret` or `options.clientSecret`.\");\n        }\n        if (prevOptions.clientSecret != null && options.clientSecret !== prevOptions.clientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the client secret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.fetchClientSecret != null && options.fetchClientSecret !== prevOptions.fetchClientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change fetchClientSecret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.onComplete != null && options.onComplete !== prevOptions.onComplete) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onComplete option after setting it.\");\n        }\n    }, [\n        prevOptions,\n        options\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmbeddedCheckoutContext.Provider, {\n        value: ctx\n    }, children);\n};\nvar EmbeddedCheckoutClientElement = function EmbeddedCheckoutClientElement(_ref) {\n    var id = _ref.id, className = _ref.className;\n    var _useEmbeddedCheckoutC = useEmbeddedCheckoutContext(), embeddedCheckout = _useEmbeddedCheckoutC.embeddedCheckout;\n    var isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        if (!isMounted.current && embeddedCheckout && domNode.current !== null) {\n            embeddedCheckout.mount(domNode.current);\n            isMounted.current = true;\n        } // Clean up on unmount\n        return function() {\n            if (isMounted.current && embeddedCheckout) {\n                try {\n                    embeddedCheckout.unmount();\n                    isMounted.current = false;\n                } catch (e) {\n                // Parent effects are destroyed before child effects, so\n                // in cases where both the EmbeddedCheckoutProvider and\n                // the EmbeddedCheckout component are removed at the same\n                // time, the embeddedCheckout instance will be destroyed,\n                // which causes an error when calling unmount.\n                }\n            }\n        };\n    }, [\n        embeddedCheckout\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: domNode,\n        id: id,\n        className: className\n    });\n}; // Only render the wrapper in a server environment.\nvar EmbeddedCheckoutServerElement = function EmbeddedCheckoutServerElement(_ref2) {\n    var id = _ref2.id, className = _ref2.className;\n    // Validate that we are in the right context by calling useEmbeddedCheckoutContext.\n    useEmbeddedCheckoutContext();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: id,\n        className: className\n    });\n};\nvar EmbeddedCheckout = isServer ? EmbeddedCheckoutServerElement : EmbeddedCheckoutClientElement;\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */ var useStripe = function useStripe() {\n    var _useElementsOrCustomC = useElementsOrCustomCheckoutSdkContextWithUseCase(\"calls useStripe()\"), stripe = _useElementsOrCustomC.stripe;\n    return stripe;\n};\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AuBankAccountElement = createElementComponent(\"auBankAccount\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardElement = createElementComponent(\"card\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardNumberElement = createElementComponent(\"cardNumber\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardExpiryElement = createElementComponent(\"cardExpiry\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardCvcElement = createElementComponent(\"cardCvc\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var FpxBankElement = createElementComponent(\"fpxBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IbanElement = createElementComponent(\"iban\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IdealBankElement = createElementComponent(\"idealBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var P24BankElement = createElementComponent(\"p24Bank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var EpsBankElement = createElementComponent(\"epsBank\", isServer);\nvar PaymentElement = createElementComponent(\"payment\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ExpressCheckoutElement = createElementComponent(\"expressCheckout\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentRequestButtonElement = createElementComponent(\"paymentRequestButton\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var LinkAuthenticationElement = createElementComponent(\"linkAuthentication\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AddressElement = createElementComponent(\"address\", isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ShippingAddressElement = createElementComponent(\"shippingAddress\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/elements/cart-element\n */ var CartElement = createElementComponent(\"cart\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentMethodMessagingElement = createElementComponent(\"paymentMethodMessaging\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AffirmMessageElement = createElementComponent(\"affirmMessage\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AfterpayClearpayMessageElement = createElementComponent(\"afterpayClearpayMessage\", isServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNTO0FBRW5DLFNBQVNFLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUNyQyxJQUFJQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO0lBRXZCLElBQUlHLE9BQU9DLHFCQUFxQixFQUFFO1FBQ2hDLElBQUlDLFVBQVVGLE9BQU9DLHFCQUFxQixDQUFDSjtRQUUzQyxJQUFJQyxnQkFBZ0I7WUFDbEJJLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO2dCQUNwQyxPQUFPSixPQUFPSyx3QkFBd0IsQ0FBQ1IsUUFBUU8sS0FBS0UsVUFBVTtZQUNoRTtRQUNGO1FBRUFQLEtBQUtRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxNQUFNRztJQUN4QjtJQUVBLE9BQU9IO0FBQ1Q7QUFFQSxTQUFTVSxlQUFlQyxNQUFNO0lBQzVCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFLElBQUksT0FBT0MsU0FBUyxDQUFDRCxFQUFFLEdBQUcsQ0FBQztRQUVwRCxJQUFJQSxJQUFJLEdBQUc7WUFDVGYsUUFBUUksT0FBT2MsU0FBUyxNQUFNQyxPQUFPLENBQUMsU0FBVUMsR0FBRztnQkFDakRDLGdCQUFnQlAsUUFBUU0sS0FBS0YsTUFBTSxDQUFDRSxJQUFJO1lBQzFDO1FBQ0YsT0FBTyxJQUFJaEIsT0FBT2tCLHlCQUF5QixFQUFFO1lBQzNDbEIsT0FBT21CLGdCQUFnQixDQUFDVCxRQUFRVixPQUFPa0IseUJBQXlCLENBQUNKO1FBQ25FLE9BQU87WUFDTGxCLFFBQVFJLE9BQU9jLFNBQVNDLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO2dCQUMzQ2hCLE9BQU9v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dkU7O0NBRUMsR0FFRCxJQUFJbUUsOEJBQThCckUsdUJBQXVCLHdCQUF3QkU7QUFDakY7O0NBRUMsR0FFRCxJQUFJb0UsNEJBQTRCdEUsdUJBQXVCLHNCQUFzQkU7QUFDN0U7O0NBRUMsR0FFRCxJQUFJcUUsaUJBQWlCdkUsdUJBQXVCLFdBQVdFO0FBQ3ZEOzs7OztDQUtDLEdBRUQsSUFBSXNFLHlCQUF5QnhFLHVCQUF1QixtQkFBbUJFO0FBQ3ZFOzs7OztDQUtDLEdBRUQsSUFBSXVFLGNBQWN6RSx1QkFBdUIsUUFBUUU7QUFDakQ7O0NBRUMsR0FFRCxJQUFJd0UsZ0NBQWdDMUUsdUJBQXVCLDBCQUEwQkU7QUFDckY7O0NBRUMsR0FFRCxJQUFJeUUsdUJBQXVCM0UsdUJBQXVCLGlCQUFpQkU7QUFDbkU7O0NBRUMsR0FFRCxJQUFJMEUsaUNBQWlDNUUsdUJBQXVCLDJCQUEyQkU7QUFFcWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wdW1wa2luLXN0b3JlLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2Rpc3QvcmVhY3Qtc3RyaXBlLmVzbS5tanM/YTE1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIHVzZVByZXZpb3VzID0gZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWYuY3VycmVudDtcbn07XG5cbnZhciBpc1Vua25vd25PYmplY3QgPSBmdW5jdGlvbiBpc1Vua25vd25PYmplY3QocmF3KSB7XG4gIHJldHVybiByYXcgIT09IG51bGwgJiYgX3R5cGVvZihyYXcpID09PSAnb2JqZWN0Jztcbn07XG52YXIgaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlKHJhdykge1xuICByZXR1cm4gaXNVbmtub3duT2JqZWN0KHJhdykgJiYgdHlwZW9mIHJhdy50aGVuID09PSAnZnVuY3Rpb24nO1xufTsgLy8gV2UgYXJlIHVzaW5nIHR5cGVzIHRvIGVuZm9yY2UgdGhlIGBzdHJpcGVgIHByb3AgaW4gdGhpcyBsaWIsXG4vLyBidXQgaW4gYW4gdW50eXBlZCBpbnRlZ3JhdGlvbiBgc3RyaXBlYCBjb3VsZCBiZSBhbnl0aGluZywgc28gd2UgbmVlZFxuLy8gdG8gZG8gc29tZSBzYW5pdHkgdmFsaWRhdGlvbiB0byBwcmV2ZW50IHR5cGUgZXJyb3JzLlxuXG52YXIgaXNTdHJpcGUgPSBmdW5jdGlvbiBpc1N0cmlwZShyYXcpIHtcbiAgcmV0dXJuIGlzVW5rbm93bk9iamVjdChyYXcpICYmIHR5cGVvZiByYXcuZWxlbWVudHMgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jcmVhdGVUb2tlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNyZWF0ZVBheW1lbnRNZXRob2QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jb25maXJtQ2FyZFBheW1lbnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgUExBSU5fT0JKRUNUX1NUUiA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gIGlmICghaXNVbmtub3duT2JqZWN0KGxlZnQpIHx8ICFpc1Vua25vd25PYmplY3QocmlnaHQpKSB7XG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICB9XG5cbiAgdmFyIGxlZnRBcnJheSA9IEFycmF5LmlzQXJyYXkobGVmdCk7XG4gIHZhciByaWdodEFycmF5ID0gQXJyYXkuaXNBcnJheShyaWdodCk7XG4gIGlmIChsZWZ0QXJyYXkgIT09IHJpZ2h0QXJyYXkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGxlZnRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChsZWZ0KSA9PT0gUExBSU5fT0JKRUNUX1NUUjtcbiAgdmFyIHJpZ2h0UGxhaW5PYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmlnaHQpID09PSBQTEFJTl9PQkpFQ1RfU1RSO1xuICBpZiAobGVmdFBsYWluT2JqZWN0ICE9PSByaWdodFBsYWluT2JqZWN0KSByZXR1cm4gZmFsc2U7IC8vIG5vdCBzdXJlIHdoYXQgc29ydCBvZiBzcGVjaWFsIG9iamVjdCB0aGlzIGlzIChyZWdleHAgaXMgb25lIG9wdGlvbiksIHNvXG4gIC8vIGZhbGxiYWNrIHRvIHJlZmVyZW5jZSBjaGVjay5cblxuICBpZiAoIWxlZnRQbGFpbk9iamVjdCAmJiAhbGVmdEFycmF5KSByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIHZhciBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnQpO1xuICB2YXIgcmlnaHRLZXlzID0gT2JqZWN0LmtleXMocmlnaHQpO1xuICBpZiAobGVmdEtleXMubGVuZ3RoICE9PSByaWdodEtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrZXlTZXQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnRLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAga2V5U2V0W2xlZnRLZXlzW2ldXSA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmlnaHRLZXlzLmxlbmd0aDsgX2kgKz0gMSkge1xuICAgIGtleVNldFtyaWdodEtleXNbX2ldXSA9IHRydWU7XG4gIH1cblxuICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzKGtleVNldCk7XG5cbiAgaWYgKGFsbEtleXMubGVuZ3RoICE9PSBsZWZ0S2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbCA9IGxlZnQ7XG4gIHZhciByID0gcmlnaHQ7XG5cbiAgdmFyIHByZWQgPSBmdW5jdGlvbiBwcmVkKGtleSkge1xuICAgIHJldHVybiBpc0VxdWFsKGxba2V5XSwgcltrZXldKTtcbiAgfTtcblxuICByZXR1cm4gYWxsS2V5cy5ldmVyeShwcmVkKTtcbn07XG5cbnZhciBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzID0gZnVuY3Rpb24gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgaW1tdXRhYmxlS2V5cykge1xuICBpZiAoIWlzVW5rbm93bk9iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLnJlZHVjZShmdW5jdGlvbiAobmV3T3B0aW9ucywga2V5KSB7XG4gICAgdmFyIGlzVXBkYXRlZCA9ICFpc1Vua25vd25PYmplY3QocHJldk9wdGlvbnMpIHx8ICFpc0VxdWFsKG9wdGlvbnNba2V5XSwgcHJldk9wdGlvbnNba2V5XSk7XG5cbiAgICBpZiAoaW1tdXRhYmxlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBpZiAoaXNVcGRhdGVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIHByb3AgY2hhbmdlOiBvcHRpb25zLlwiLmNvbmNhdChrZXksIFwiIGlzIG5vdCBhIG11dGFibGUgcHJvcGVydHkuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCFpc1VwZGF0ZWQpIHtcbiAgICAgIHJldHVybiBuZXdPcHRpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbmV3T3B0aW9ucyB8fCB7fSksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgb3B0aW9uc1trZXldKSk7XG4gIH0sIG51bGwpO1xufTtcblxudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SJDIgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBFbGVtZW50c2AuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nOyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYiwgYnV0IGluIGEgcmVhbFxuLy8gaW50ZWdyYXRpb24gYHN0cmlwZWAgY291bGQgYmUgYW55dGhpbmcsIHNvIHdlIG5lZWQgdG8gZG8gc29tZSBzYW5pdHlcbi8vIHZhbGlkYXRpb24gdG8gcHJldmVudCB0eXBlIGVycm9ycy5cblxudmFyIHZhbGlkYXRlU3RyaXBlID0gZnVuY3Rpb24gdmFsaWRhdGVTdHJpcGUobWF5YmVTdHJpcGUpIHtcbiAgdmFyIGVycm9yTXNnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBJTlZBTElEX1NUUklQRV9FUlJPUiQyO1xuXG4gIGlmIChtYXliZVN0cmlwZSA9PT0gbnVsbCB8fCBpc1N0cmlwZShtYXliZVN0cmlwZSkpIHtcbiAgICByZXR1cm4gbWF5YmVTdHJpcGU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xufTtcblxudmFyIHBhcnNlU3RyaXBlUHJvcCA9IGZ1bmN0aW9uIHBhcnNlU3RyaXBlUHJvcChyYXcpIHtcbiAgdmFyIGVycm9yTXNnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBJTlZBTElEX1NUUklQRV9FUlJPUiQyO1xuXG4gIGlmIChpc1Byb21pc2UocmF3KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdhc3luYycsXG4gICAgICBzdHJpcGVQcm9taXNlOiBQcm9taXNlLnJlc29sdmUocmF3KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlU3RyaXBlKHJlc3VsdCwgZXJyb3JNc2cpO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0cmlwZSA9IHZhbGlkYXRlU3RyaXBlKHJhdywgZXJyb3JNc2cpO1xuXG4gIGlmIChzdHJpcGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAnZW1wdHknXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnOiAnc3luYycsXG4gICAgc3RyaXBlOiBzdHJpcGVcbiAgfTtcbn07XG5cbnZhciByZWdpc3RlcldpdGhTdHJpcGVKcyA9IGZ1bmN0aW9uIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKHN0cmlwZSkge1xuICBpZiAoIXN0cmlwZSB8fCAhc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIgfHwgIXN0cmlwZS5yZWdpc3RlckFwcEluZm8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcih7XG4gICAgbmFtZTogJ3JlYWN0LXN0cmlwZS1qcycsXG4gICAgdmVyc2lvbjogXCIyLjYuMlwiXG4gIH0pO1xuXG4gIHN0cmlwZS5yZWdpc3RlckFwcEluZm8oe1xuICAgIG5hbWU6ICdyZWFjdC1zdHJpcGUtanMnLFxuICAgIHZlcnNpb246IFwiMi42LjJcIixcbiAgICB1cmw6ICdodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QnXG4gIH0pO1xufTtcblxudmFyIEVsZW1lbnRzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRWxlbWVudHNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0VsZW1lbnRzQ29udGV4dCc7XG52YXIgcGFyc2VFbGVtZW50c0NvbnRleHQgPSBmdW5jdGlvbiBwYXJzZUVsZW1lbnRzQ29udGV4dChjdHgsIHVzZUNhc2UpIHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBFbGVtZW50cyBjb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2UsIFwiIGluIGFuIDxFbGVtZW50cz4gcHJvdmlkZXIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xudmFyIENhcnRFbGVtZW50Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuQ2FydEVsZW1lbnRDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0NhcnRFbGVtZW50Q29udGV4dCc7XG52YXIgcGFyc2VDYXJ0RWxlbWVudENvbnRleHQgPSBmdW5jdGlvbiBwYXJzZUNhcnRFbGVtZW50Q29udGV4dChjdHgsIHVzZUNhc2UpIHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBFbGVtZW50cyBjb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2UsIFwiIGluIGFuIDxFbGVtZW50cz4gcHJvdmlkZXIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xuLyoqXG4gKiBUaGUgYEVsZW1lbnRzYCBwcm92aWRlciBhbGxvd3MgeW91IHRvIHVzZSBbRWxlbWVudCBjb21wb25lbnRzXShodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzKSBhbmQgYWNjZXNzIHRoZSBbU3RyaXBlIG9iamVjdF0oaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3MvanMvaW5pdGlhbGl6aW5nKSBpbiBhbnkgbmVzdGVkIGNvbXBvbmVudC5cbiAqIFJlbmRlciBhbiBgRWxlbWVudHNgIHByb3ZpZGVyIGF0IHRoZSByb290IG9mIHlvdXIgUmVhY3QgYXBwIHNvIHRoYXQgaXQgaXMgYXZhaWxhYmxlIGV2ZXJ5d2hlcmUgeW91IG5lZWQgaXQuXG4gKlxuICogVG8gdXNlIHRoZSBgRWxlbWVudHNgIHByb3ZpZGVyLCBjYWxsIGBsb2FkU3RyaXBlYCBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2Agd2l0aCB5b3VyIHB1Ymxpc2hhYmxlIGtleS5cbiAqIFRoZSBgbG9hZFN0cmlwZWAgZnVuY3Rpb24gd2lsbCBhc3luY2hyb25vdXNseSBsb2FkIHRoZSBTdHJpcGUuanMgc2NyaXB0IGFuZCBpbml0aWFsaXplIGEgYFN0cmlwZWAgb2JqZWN0LlxuICogUGFzcyB0aGUgcmV0dXJuZWQgYFByb21pc2VgIHRvIGBFbGVtZW50c2AuXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3ZpZGVyXG4gKi9cblxudmFyIEVsZW1lbnRzID0gZnVuY3Rpb24gRWxlbWVudHMoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCk7XG4gIH0sIFtyYXdTdHJpcGVQcm9wXSk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBjYXJ0ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENhcnQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICBfUmVhY3QkdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlMywgMiksXG4gICAgICBjYXJ0U3RhdGUgPSBfUmVhY3QkdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0Q2FydFN0YXRlID0gX1JlYWN0JHVzZVN0YXRlNFsxXTsgLy8gRm9yIGEgc3luYyBzdHJpcGUgaW5zdGFuY2UsIGluaXRpYWxpemUgaW50byBjb250ZXh0XG5cblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlNSA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyaXBlOiBwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlIDogbnVsbCxcbiAgICAgIGVsZW1lbnRzOiBwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlLmVsZW1lbnRzKG9wdGlvbnMpIDogbnVsbFxuICAgIH07XG4gIH0pLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlNiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZTUsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlNlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGU2WzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzTW91bnRlZCA9IHRydWU7XG5cbiAgICB2YXIgc2FmZVNldENvbnRleHQgPSBmdW5jdGlvbiBzYWZlU2V0Q29udGV4dChzdHJpcGUpIHtcbiAgICAgIHNldENvbnRleHQoZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAvLyBuby1vcCBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdHJpcGUgaW5zdGFuY2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9zdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2lzc3Vlcy8yOTYpXG4gICAgICAgIGlmIChjdHguc3RyaXBlKSByZXR1cm4gY3R4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmlwZTogc3RyaXBlLFxuICAgICAgICAgIGVsZW1lbnRzOiBzdHJpcGUuZWxlbWVudHMob3B0aW9ucylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07IC8vIEZvciBhbiBhc3luYyBzdHJpcGVQcm9taXNlLCBzdG9yZSBpdCBpbiBjb250ZXh0IG9uY2UgcmVzb2x2ZWRcblxuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIEVsZW1lbnRzIGNvbnRleHQgaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkXG4gICAgICAgICAgLy8gYW5kIHN0cmlwZSBpcyBub3QgbnVsbC4gV2UgYWxsb3cgc3RyaXBlIHRvIGJlIG51bGwgdG8gbWFrZVxuICAgICAgICAgIC8vIGhhbmRsaW5nIFNTUiBlYXNpZXIuXG4gICAgICAgICAgc2FmZVNldENvbnRleHQoc3RyaXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIC8vIE9yLCBoYW5kbGUgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSBnb2luZyBmcm9tIG51bGwgLT4gcG9wdWxhdGVkXG4gICAgICBzYWZlU2V0Q29udGV4dChwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZCwgY3R4LCBvcHRpb25zXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBzdHJpcGUgcHJvcFxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbGVtZW50czogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGBzdHJpcGVgIHByb3AgYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2U3RyaXBlLCByYXdTdHJpcGVQcm9wXSk7IC8vIEFwcGx5IHVwZGF0ZXMgdG8gZWxlbWVudHMgd2hlbiBvcHRpb25zIHByb3AgaGFzIHJlbGV2YW50IGNoYW5nZXNcblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWN0eC5lbGVtZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydjbGllbnRTZWNyZXQnLCAnZm9udHMnXSk7XG5cbiAgICBpZiAodXBkYXRlcykge1xuICAgICAgY3R4LmVsZW1lbnRzLnVwZGF0ZSh1cGRhdGVzKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmVsZW1lbnRzXSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGN0eC5zdHJpcGUpO1xuICB9LCBbY3R4LnN0cmlwZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWxlbWVudHNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDYXJ0RWxlbWVudENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgY2FydDogY2FydCxcbiAgICAgIHNldENhcnQ6IHNldENhcnQsXG4gICAgICBjYXJ0U3RhdGU6IGNhcnRTdGF0ZSxcbiAgICAgIHNldENhcnRTdGF0ZTogc2V0Q2FydFN0YXRlXG4gICAgfVxuICB9LCBjaGlsZHJlbikpO1xufTtcbkVsZW1lbnRzLnByb3BUeXBlcyA9IHtcbiAgc3RyaXBlOiBQcm9wVHlwZXMuYW55LFxuICBvcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0XG59O1xudmFyIHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlID0gZnVuY3Rpb24gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UodXNlQ2FzZU1lc3NhZ2UpIHtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRWxlbWVudHNDb250ZXh0KTtcbiAgcmV0dXJuIHBhcnNlRWxlbWVudHNDb250ZXh0KGN0eCwgdXNlQ2FzZU1lc3NhZ2UpO1xufTtcbnZhciBEVU1NWV9DQVJUX0VMRU1FTlRfQ09OVEVYVCA9IHtcbiAgY2FydDogbnVsbCxcbiAgY2FydFN0YXRlOiBudWxsLFxuICBzZXRDYXJ0OiBmdW5jdGlvbiBzZXRDYXJ0KCkge30sXG4gIHNldENhcnRTdGF0ZTogZnVuY3Rpb24gc2V0Q2FydFN0YXRlKCkge31cbn07XG52YXIgdXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlTWVzc2FnZSkge1xuICB2YXIgaXNJbkN1c3RvbUNoZWNrb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ2FydEVsZW1lbnRDb250ZXh0KTtcblxuICBpZiAoaXNJbkN1c3RvbUNoZWNrb3V0KSB7XG4gICAgcmV0dXJuIERVTU1ZX0NBUlRfRUxFTUVOVF9DT05URVhUO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlQ2FydEVsZW1lbnRDb250ZXh0KGN0eCwgdXNlQ2FzZU1lc3NhZ2UpO1xufTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I3VzZWVsZW1lbnRzLWhvb2tcbiAqL1xuXG52YXIgdXNlRWxlbWVudHMgPSBmdW5jdGlvbiB1c2VFbGVtZW50cygpIHtcbiAgdmFyIF91c2VFbGVtZW50c0NvbnRleHRXaSA9IHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VFbGVtZW50cygpJyksXG4gICAgICBlbGVtZW50cyA9IF91c2VFbGVtZW50c0NvbnRleHRXaS5lbGVtZW50cztcblxuICByZXR1cm4gZWxlbWVudHM7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9wYXltZW50cy9jaGVja291dC9jYXJ0LWVsZW1lbnRcbiAqL1xuXG52YXIgdXNlQ2FydEVsZW1lbnQgPSBmdW5jdGlvbiB1c2VDYXJ0RWxlbWVudCgpIHtcbiAgdmFyIF91c2VDYXJ0RWxlbWVudENvbnRleCA9IHVzZUNhcnRFbGVtZW50Q29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VDYXJ0RWxlbWVudCgpJyksXG4gICAgICBjYXJ0ID0gX3VzZUNhcnRFbGVtZW50Q29udGV4LmNhcnQ7XG5cbiAgcmV0dXJuIGNhcnQ7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9wYXltZW50cy9jaGVja291dC9jYXJ0LWVsZW1lbnRcbiAqL1xuXG52YXIgdXNlQ2FydEVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIHVzZUNhcnRFbGVtZW50U3RhdGUoKSB7XG4gIHZhciBfdXNlQ2FydEVsZW1lbnRDb250ZXgyID0gdXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUNhcnRFbGVtZW50U3RhdGUoKScpLFxuICAgICAgY2FydFN0YXRlID0gX3VzZUNhcnRFbGVtZW50Q29udGV4Mi5jYXJ0U3RhdGU7XG5cbiAgcmV0dXJuIGNhcnRTdGF0ZTtcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1jb25zdW1lclxuICovXG5cbnZhciBFbGVtZW50c0NvbnN1bWVyID0gZnVuY3Rpb24gRWxlbWVudHNDb25zdW1lcihfcmVmMikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbjtcbiAgdmFyIGN0eCA9IHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKCdtb3VudHMgPEVsZW1lbnRzQ29uc3VtZXI+Jyk7IC8vIEFzc2VydCB0byBzYXRpc2Z5IHRoZSBidXN0ZWQgUmVhY3QuRkMgcmV0dXJuIHR5cGUgKGl0IHNob3VsZCBiZSBSZWFjdE5vZGUpXG5cbiAgcmV0dXJuIGNoaWxkcmVuKGN0eCk7XG59O1xuRWxlbWVudHNDb25zdW1lci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59O1xuXG52YXIgdXNlQXR0YWNoRXZlbnQgPSBmdW5jdGlvbiB1c2VBdHRhY2hFdmVudChlbGVtZW50LCBldmVudCwgY2IpIHtcbiAgdmFyIGNiRGVmaW5lZCA9ICEhY2I7XG4gIHZhciBjYlJlZiA9IFJlYWN0LnVzZVJlZihjYik7IC8vIEluIG1hbnkgaW50ZWdyYXRpb25zIHRoZSBjYWxsYmFjayBwcm9wIGNoYW5nZXMgb24gZWFjaCByZW5kZXIuXG4gIC8vIFVzaW5nIGEgcmVmIHNhdmVzIHVzIGZyb20gY2FsbGluZyBlbGVtZW50Lm9uLy5vZmYgZXZlcnkgcmVuZGVyLlxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgY2JSZWYuY3VycmVudCA9IGNiO1xuICB9LCBbY2JdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNiRGVmaW5lZCB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIHZhciBkZWNvcmF0ZWRDYiA9IGZ1bmN0aW9uIGRlY29yYXRlZENiKCkge1xuICAgICAgaWYgKGNiUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2JSZWYuY3VycmVudC5hcHBseShjYlJlZiwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlbWVudC5vbihldmVudCwgZGVjb3JhdGVkQ2IpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50Lm9mZihldmVudCwgZGVjb3JhdGVkQ2IpO1xuICAgIH07XG4gIH0sIFtjYkRlZmluZWQsIGV2ZW50LCBlbGVtZW50LCBjYlJlZl0pO1xufTtcblxudmFyIF9leGNsdWRlZCA9IFtcIm9uXCIsIFwic2Vzc2lvblwiXTtcbnZhciBDdXN0b21DaGVja291dFNka0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdDdXN0b21DaGVja291dFNka0NvbnRleHQnO1xudmFyIHBhcnNlQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0ID0gZnVuY3Rpb24gcGFyc2VDdXN0b21DaGVja291dFNka0NvbnRleHQoY3R4LCB1c2VDYXNlKSB7XG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgQ3VzdG9tQ2hlY2tvdXRQcm92aWRlciBjb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2UsIFwiIGluIGFuIDxDdXN0b21DaGVja291dFByb3ZpZGVyPiBwcm92aWRlci5cIikpO1xuICB9XG5cbiAgcmV0dXJuIGN0eDtcbn07XG52YXIgQ3VzdG9tQ2hlY2tvdXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5DdXN0b21DaGVja291dENvbnRleHQuZGlzcGxheU5hbWUgPSAnQ3VzdG9tQ2hlY2tvdXRDb250ZXh0JztcbnZhciBleHRyYWN0Q3VzdG9tQ2hlY2tvdXRDb250ZXh0VmFsdWUgPSBmdW5jdGlvbiBleHRyYWN0Q3VzdG9tQ2hlY2tvdXRDb250ZXh0VmFsdWUoY3VzdG9tQ2hlY2tvdXRTZGssIHNlc3Npb25TdGF0ZSkge1xuICBpZiAoIWN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjdXN0b21DaGVja291dFNkay5vbjtcbiAgICAgIGN1c3RvbUNoZWNrb3V0U2RrLnNlc3Npb247XG4gICAgICB2YXIgYWN0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhjdXN0b21DaGVja291dFNkaywgX2V4Y2x1ZGVkKTtcblxuICBpZiAoIXNlc3Npb25TdGF0ZSkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYWN0aW9ucyksIGN1c3RvbUNoZWNrb3V0U2RrLnNlc3Npb24oKSk7XG4gIH1cblxuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGFjdGlvbnMpLCBzZXNzaW9uU3RhdGUpO1xufTtcbnZhciBJTlZBTElEX1NUUklQRV9FUlJPUiQxID0gJ0ludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgQ3VzdG9tQ2hlY2tvdXRQcm92aWRlcmAuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nO1xudmFyIEN1c3RvbUNoZWNrb3V0UHJvdmlkZXIgPSBmdW5jdGlvbiBDdXN0b21DaGVja291dFByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3AsIElOVkFMSURfU1RSSVBFX0VSUk9SJDEpO1xuICB9LCBbcmF3U3RyaXBlUHJvcF0pOyAvLyBTdGF0ZSB1c2VkIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIgd2hlbiBzZGsuc2Vzc2lvbiBpcyB1cGRhdGVkXG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBzZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldFNlc3Npb24gPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpcGU6IHBhcnNlZC50YWcgPT09ICdzeW5jJyA/IHBhcnNlZC5zdHJpcGUgOiBudWxsLFxuICAgICAgY3VzdG9tQ2hlY2tvdXRTZGs6IG51bGxcbiAgICB9O1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUzLCAyKSxcbiAgICAgIGN0eCA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRDb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcblxuICB2YXIgc2FmZVNldENvbnRleHQgPSBmdW5jdGlvbiBzYWZlU2V0Q29udGV4dChzdHJpcGUsIGN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgc2V0Q29udGV4dChmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAoY3R4LnN0cmlwZSAmJiBjdHguY3VzdG9tQ2hlY2tvdXRTZGspIHtcbiAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaXBlOiBzdHJpcGUsXG4gICAgICAgIGN1c3RvbUNoZWNrb3V0U2RrOiBjdXN0b21DaGVja291dFNka1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTsgLy8gUmVmIHVzZWQgdG8gYXZvaWQgY2FsbGluZyBpbml0Q3VzdG9tQ2hlY2tvdXQgbXVsdGlwbGUgdGltZXMgd2hlbiBvcHRpb25zIGNoYW5nZXNcblxuXG4gIHZhciBpbml0Q3VzdG9tQ2hlY2tvdXRDYWxsZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCAmJiAhaW5pdEN1c3RvbUNoZWNrb3V0Q2FsbGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBjb250ZXh0IGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZFxuICAgICAgICAgIC8vIGFuZCBzdHJpcGUgaXMgbm90IG51bGwuIFdlIGFsbG93IHN0cmlwZSB0byBiZSBudWxsIHRvIG1ha2VcbiAgICAgICAgICAvLyBoYW5kbGluZyBTU1IgZWFzaWVyLlxuICAgICAgICAgIGluaXRDdXN0b21DaGVja291dENhbGxlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBzdHJpcGUuaW5pdEN1c3RvbUNoZWNrb3V0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tQ2hlY2tvdXRTZGspIHtcbiAgICAgICAgICAgICAgc2FmZVNldENvbnRleHQoc3RyaXBlLCBjdXN0b21DaGVja291dFNkayk7XG4gICAgICAgICAgICAgIGN1c3RvbUNoZWNrb3V0U2RrLm9uKCdjaGFuZ2UnLCBzZXRTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgcGFyc2VkLnN0cmlwZSAmJiAhaW5pdEN1c3RvbUNoZWNrb3V0Q2FsbGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIGluaXRDdXN0b21DaGVja291dENhbGxlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHBhcnNlZC5zdHJpcGUuaW5pdEN1c3RvbUNoZWNrb3V0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgICAgIGlmIChjdXN0b21DaGVja291dFNkaykge1xuICAgICAgICAgIHNhZmVTZXRDb250ZXh0KHBhcnNlZC5zdHJpcGUsIGN1c3RvbUNoZWNrb3V0U2RrKTtcbiAgICAgICAgICBjdXN0b21DaGVja291dFNkay5vbignY2hhbmdlJywgc2V0U2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbcGFyc2VkLCBjdHgsIG9wdGlvbnMsIHNldFNlc3Npb25dKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wXG5cbiAgdmFyIHByZXZTdHJpcGUgPSB1c2VQcmV2aW91cyhyYXdTdHJpcGVQcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldlN0cmlwZSAhPT0gbnVsbCAmJiBwcmV2U3RyaXBlICE9PSByYXdTdHJpcGVQcm9wKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEN1c3RvbUNoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBBcHBseSB1cGRhdGVzIHRvIGVsZW1lbnRzIHdoZW4gb3B0aW9ucyBwcm9wIGhhcyByZWxldmFudCBjaGFuZ2VzXG5cbiAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wcmV2T3B0aW9ucyRlbGVtZW50cywgX29wdGlvbnMkZWxlbWVudHNPcHRpO1xuXG4gICAgaWYgKCFjdHguY3VzdG9tQ2hlY2tvdXRTZGspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jbGllbnRTZWNyZXQgJiYgIWlzVW5rbm93bk9iamVjdChwcmV2T3B0aW9ucykgJiYgIWlzRXF1YWwob3B0aW9ucy5jbGllbnRTZWNyZXQsIHByZXZPcHRpb25zLmNsaWVudFNlY3JldCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2U6IG9wdGlvbnMuY2xpZW50X3NlY3JldCBpcyBub3QgYSBtdXRhYmxlIHByb3BlcnR5LicpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c0FwcGVhcmFuY2UgPSBwcmV2T3B0aW9ucyA9PT0gbnVsbCB8fCBwcmV2T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9wcmV2T3B0aW9ucyRlbGVtZW50cyA9IHByZXZPcHRpb25zLmVsZW1lbnRzT3B0aW9ucykgPT09IG51bGwgfHwgX3ByZXZPcHRpb25zJGVsZW1lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJldk9wdGlvbnMkZWxlbWVudHMuYXBwZWFyYW5jZTtcbiAgICB2YXIgY3VycmVudEFwcGVhcmFuY2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfb3B0aW9ucyRlbGVtZW50c09wdGkgPSBvcHRpb25zLmVsZW1lbnRzT3B0aW9ucykgPT09IG51bGwgfHwgX29wdGlvbnMkZWxlbWVudHNPcHRpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRlbGVtZW50c09wdGkuYXBwZWFyYW5jZTtcblxuICAgIGlmIChjdXJyZW50QXBwZWFyYW5jZSAmJiAhaXNFcXVhbChjdXJyZW50QXBwZWFyYW5jZSwgcHJldmlvdXNBcHBlYXJhbmNlKSkge1xuICAgICAgY3R4LmN1c3RvbUNoZWNrb3V0U2RrLmNoYW5nZUFwcGVhcmFuY2UoY3VycmVudEFwcGVhcmFuY2UpO1xuICAgIH1cbiAgfSwgW29wdGlvbnMsIHByZXZPcHRpb25zLCBjdHguY3VzdG9tQ2hlY2tvdXRTZGtdKTsgLy8gQXR0YWNoIHJlYWN0LXN0cmlwZS1qcyB2ZXJzaW9uIHRvIHN0cmlwZS5qcyBpbnN0YW5jZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXJXaXRoU3RyaXBlSnMoY3R4LnN0cmlwZSk7XG4gIH0sIFtjdHguc3RyaXBlXSk7XG4gIHZhciBjdXN0b21DaGVja291dENvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBleHRyYWN0Q3VzdG9tQ2hlY2tvdXRDb250ZXh0VmFsdWUoY3R4LmN1c3RvbUNoZWNrb3V0U2RrLCBzZXNzaW9uKTtcbiAgfSwgW2N0eC5jdXN0b21DaGVja291dFNkaywgc2Vzc2lvbl0pO1xuXG4gIGlmICghY3R4LmN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21DaGVja291dENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3VzdG9tQ2hlY2tvdXRDb250ZXh0VmFsdWVcbiAgfSwgY2hpbGRyZW4pKTtcbn07XG5DdXN0b21DaGVja291dFByb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgc3RyaXBlOiBQcm9wVHlwZXMuYW55LFxuICBvcHRpb25zOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGNsaWVudFNlY3JldDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGVsZW1lbnRzT3B0aW9uczogUHJvcFR5cGVzLm9iamVjdFxuICB9KS5pc1JlcXVpcmVkXG59O1xudmFyIHVzZUN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlID0gZnVuY3Rpb24gdXNlQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UodXNlQ2FzZVN0cmluZykge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChDdXN0b21DaGVja291dFNka0NvbnRleHQpO1xuICByZXR1cm4gcGFyc2VDdXN0b21DaGVja291dFNka0NvbnRleHQoY3R4LCB1c2VDYXNlU3RyaW5nKTtcbn07XG52YXIgdXNlRWxlbWVudHNPckN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlID0gZnVuY3Rpb24gdXNlRWxlbWVudHNPckN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VTdHJpbmcpIHtcbiAgdmFyIGN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0KTtcbiAgdmFyIGVsZW1lbnRzQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRWxlbWVudHNDb250ZXh0KTtcblxuICBpZiAoY3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0ICYmIGVsZW1lbnRzQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3Qgd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IFwiLmNvbmNhdCh1c2VDYXNlU3RyaW5nLCBcIiBpbiBib3RoIDxDdXN0b21DaGVja291dFByb3ZpZGVyPiBhbmQgPEVsZW1lbnRzPiBwcm92aWRlcnMuXCIpKTtcbiAgfVxuXG4gIGlmIChjdXN0b21DaGVja291dFNka0NvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyc2VDdXN0b21DaGVja291dFNka0NvbnRleHQoY3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0LCB1c2VDYXNlU3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUVsZW1lbnRzQ29udGV4dChlbGVtZW50c0NvbnRleHQsIHVzZUNhc2VTdHJpbmcpO1xufTtcbnZhciB1c2VDdXN0b21DaGVja291dCA9IGZ1bmN0aW9uIHVzZUN1c3RvbUNoZWNrb3V0KCkge1xuICAvLyBlbnN1cmUgaXQncyBpbiBDdXN0b21DaGVja291dFByb3ZpZGVyXG4gIHVzZUN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VDdXN0b21DaGVja291dCgpJyk7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KEN1c3RvbUNoZWNrb3V0Q29udGV4dCk7XG5cbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIEN1c3RvbUNoZWNrb3V0IENvbnRleHQ7IFlvdSBuZWVkIHRvIHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBjYWxscyB1c2VDdXN0b21DaGVja291dCgpIGluIGFuIDxDdXN0b21DaGVja291dFByb3ZpZGVyPiBwcm92aWRlci4nKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xuXG52YXIgY2FwaXRhbGl6ZWQgPSBmdW5jdGlvbiBjYXBpdGFsaXplZChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbnZhciBjcmVhdGVFbGVtZW50Q29tcG9uZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudENvbXBvbmVudCh0eXBlLCBpc1NlcnZlcikge1xuICB2YXIgZGlzcGxheU5hbWUgPSBcIlwiLmNvbmNhdChjYXBpdGFsaXplZCh0eXBlKSwgXCJFbGVtZW50XCIpO1xuXG4gIHZhciBDbGllbnRFbGVtZW50ID0gZnVuY3Rpb24gQ2xpZW50RWxlbWVudChfcmVmKSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXG4gICAgICAgIG9uQmx1ciA9IF9yZWYub25CbHVyLFxuICAgICAgICBvbkZvY3VzID0gX3JlZi5vbkZvY3VzLFxuICAgICAgICBvblJlYWR5ID0gX3JlZi5vblJlYWR5LFxuICAgICAgICBvbkNoYW5nZSA9IF9yZWYub25DaGFuZ2UsXG4gICAgICAgIG9uRXNjYXBlID0gX3JlZi5vbkVzY2FwZSxcbiAgICAgICAgb25DbGljayA9IF9yZWYub25DbGljayxcbiAgICAgICAgb25Mb2FkRXJyb3IgPSBfcmVmLm9uTG9hZEVycm9yLFxuICAgICAgICBvbkxvYWRlclN0YXJ0ID0gX3JlZi5vbkxvYWRlclN0YXJ0LFxuICAgICAgICBvbk5ldHdvcmtzQ2hhbmdlID0gX3JlZi5vbk5ldHdvcmtzQ2hhbmdlLFxuICAgICAgICBvbkNoZWNrb3V0ID0gX3JlZi5vbkNoZWNrb3V0LFxuICAgICAgICBvbkxpbmVJdGVtQ2xpY2sgPSBfcmVmLm9uTGluZUl0ZW1DbGljayxcbiAgICAgICAgb25Db25maXJtID0gX3JlZi5vbkNvbmZpcm0sXG4gICAgICAgIG9uQ2FuY2VsID0gX3JlZi5vbkNhbmNlbCxcbiAgICAgICAgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UgPSBfcmVmLm9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlLFxuICAgICAgICBvblNoaXBwaW5nUmF0ZUNoYW5nZSA9IF9yZWYub25TaGlwcGluZ1JhdGVDaGFuZ2U7XG4gICAgdmFyIGN0eCA9IHVzZUVsZW1lbnRzT3JDdXN0b21DaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIikpO1xuICAgIHZhciBlbGVtZW50cyA9ICdlbGVtZW50cycgaW4gY3R4ID8gY3R4LmVsZW1lbnRzIDogbnVsbDtcbiAgICB2YXIgY3VzdG9tQ2hlY2tvdXRTZGsgPSAnY3VzdG9tQ2hlY2tvdXRTZGsnIGluIGN0eCA/IGN0eC5jdXN0b21DaGVja291dFNkayA6IG51bGw7XG5cbiAgICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgICBlbGVtZW50ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgICAgc2V0RWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgICB2YXIgZWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICB2YXIgZG9tTm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICAgIHZhciBfdXNlQ2FydEVsZW1lbnRDb250ZXggPSB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIiksICdjdXN0b21DaGVja291dFNkaycgaW4gY3R4KSxcbiAgICAgICAgc2V0Q2FydCA9IF91c2VDYXJ0RWxlbWVudENvbnRleC5zZXRDYXJ0LFxuICAgICAgICBzZXRDYXJ0U3RhdGUgPSBfdXNlQ2FydEVsZW1lbnRDb250ZXguc2V0Q2FydFN0YXRlOyAvLyBGb3IgZXZlcnkgZXZlbnQgd2hlcmUgdGhlIG1lcmNoYW50IHByb3ZpZGVzIGEgY2FsbGJhY2ssIGNhbGwgZWxlbWVudC5vblxuICAgIC8vIHdpdGggdGhhdCBjYWxsYmFjay4gSWYgdGhlIG1lcmNoYW50IGV2ZXIgY2hhbmdlcyB0aGUgY2FsbGJhY2ssIHJlbW92ZXNcbiAgICAvLyB0aGUgb2xkIGNhbGxiYWNrIHdpdGggZWxlbWVudC5vZmYgYW5kIHRoZW4gY2FsbCBlbGVtZW50Lm9uIHdpdGggdGhlIG5ldyBvbmUuXG5cblxuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdibHVyJywgb25CbHVyKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZm9jdXMnLCBvbkZvY3VzKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZXNjYXBlJywgb25Fc2NhcGUpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsb2FkZXJyb3InLCBvbkxvYWRFcnJvcik7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2xvYWRlcnN0YXJ0Jywgb25Mb2FkZXJTdGFydCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ25ldHdvcmtzY2hhbmdlJywgb25OZXR3b3Jrc0NoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2xpbmVpdGVtY2xpY2snLCBvbkxpbmVJdGVtQ2xpY2spO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjb25maXJtJywgb25Db25maXJtKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2FuY2VsJywgb25DYW5jZWwpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdzaGlwcGluZ2FkZHJlc3NjaGFuZ2UnLCBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NoaXBwaW5ncmF0ZWNoYW5nZScsIG9uU2hpcHBpbmdSYXRlQ2hhbmdlKTtcbiAgICB2YXIgcmVhZHlDYWxsYmFjaztcblxuICAgIGlmICh0eXBlID09PSAnY2FydCcpIHtcbiAgICAgIHJlYWR5Q2FsbGJhY2sgPSBmdW5jdGlvbiByZWFkeUNhbGxiYWNrKGV2ZW50KSB7XG4gICAgICAgIHNldENhcnRTdGF0ZShldmVudCk7XG4gICAgICAgIG9uUmVhZHkgJiYgb25SZWFkeShldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob25SZWFkeSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdleHByZXNzQ2hlY2tvdXQnKSB7XG4gICAgICAgIC8vIFBhc3NlcyB0aHJvdWdoIHRoZSBldmVudCwgd2hpY2ggaW5jbHVkZXMgdmlzaWJsZSBQTSB0eXBlc1xuICAgICAgICByZWFkeUNhbGxiYWNrID0gb25SZWFkeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvdGhlciBFbGVtZW50cywgcGFzcyB0aHJvdWdoIHRoZSBFbGVtZW50IGl0c2VsZi5cbiAgICAgICAgcmVhZHlDYWxsYmFjayA9IGZ1bmN0aW9uIHJlYWR5Q2FsbGJhY2soKSB7XG4gICAgICAgICAgb25SZWFkeShlbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAncmVhZHknLCByZWFkeUNhbGxiYWNrKTtcbiAgICB2YXIgY2hhbmdlQ2FsbGJhY2sgPSB0eXBlID09PSAnY2FydCcgPyBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHNldENhcnRTdGF0ZShldmVudCk7XG4gICAgICBvbkNoYW5nZSAmJiBvbkNoYW5nZShldmVudCk7XG4gICAgfSA6IG9uQ2hhbmdlO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjaGFuZ2UnLCBjaGFuZ2VDYWxsYmFjayk7XG4gICAgdmFyIGNoZWNrb3V0Q2FsbGJhY2sgPSB0eXBlID09PSAnY2FydCcgPyBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHNldENhcnRTdGF0ZShldmVudCk7XG4gICAgICBvbkNoZWNrb3V0ICYmIG9uQ2hlY2tvdXQoZXZlbnQpO1xuICAgIH0gOiBvbkNoZWNrb3V0O1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjaGVja291dCcsIGNoZWNrb3V0Q2FsbGJhY2spO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZWxlbWVudFJlZi5jdXJyZW50ID09PSBudWxsICYmIGRvbU5vZGUuY3VycmVudCAhPT0gbnVsbCAmJiAoZWxlbWVudHMgfHwgY3VzdG9tQ2hlY2tvdXRTZGspKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoY3VzdG9tQ2hlY2tvdXRTZGspIHtcbiAgICAgICAgICBuZXdFbGVtZW50ID0gY3VzdG9tQ2hlY2tvdXRTZGsuY3JlYXRlRWxlbWVudCh0eXBlLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50cykge1xuICAgICAgICAgIG5ld0VsZW1lbnQgPSBlbGVtZW50cy5jcmVhdGUodHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NhcnQnICYmIHNldENhcnQpIHtcbiAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgZWxlbWVudHMuY3JlYXRlIHJldHVybiB2YWx1ZSBtdXN0IGJlIG9mIHR5cGUgU3RyaXBlQ2FydEVsZW1lbnQgaWYgdHlwZSBpcyAnY2FydCcsXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBjYXN0IGJlY2F1c2UgdHlwZXNjcmlwdCBpcyBub3QgYWJsZSB0byBpbmZlciB3aGljaCBvdmVybG9hZGVkIG1ldGhvZCBpcyB1c2VkIGJhc2VkIG9mZiBwYXJhbSB0eXBlXG4gICAgICAgICAgc2V0Q2FydChuZXdFbGVtZW50KTtcbiAgICAgICAgfSAvLyBTdG9yZSBlbGVtZW50IGluIGEgcmVmIHRvIGVuc3VyZSBpdCdzIF9pbW1lZGlhdGVseV8gYXZhaWxhYmxlIGluIGNsZWFudXAgaG9va3MgaW4gU3RyaWN0TW9kZVxuXG5cbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gbmV3RWxlbWVudDsgLy8gU3RvcmUgZWxlbWVudCBpbiBzdGF0ZSB0byBmYWNpbGl0YXRlIGV2ZW50IGxpc3RlbmVyIGF0dGFjaG1lbnRcblxuICAgICAgICBzZXRFbGVtZW50KG5ld0VsZW1lbnQpO1xuXG4gICAgICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICAgICAgbmV3RWxlbWVudC5tb3VudChkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2VsZW1lbnRzLCBjdXN0b21DaGVja291dFNkaywgb3B0aW9ucywgc2V0Q2FydF0pO1xuICAgIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydwYXltZW50UmVxdWVzdCddKTtcblxuICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LnVwZGF0ZSh1cGRhdGVzKTtcbiAgICAgIH1cbiAgICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnNdKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCAmJiB0eXBlb2YgZWxlbWVudFJlZi5jdXJyZW50LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBEbyBub3RoaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICByZWY6IGRvbU5vZGVcbiAgICB9KTtcbiAgfTsgLy8gT25seSByZW5kZXIgdGhlIEVsZW1lbnQgd3JhcHBlciBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cblxuXG4gIHZhciBTZXJ2ZXJFbGVtZW50ID0gZnVuY3Rpb24gU2VydmVyRWxlbWVudChwcm9wcykge1xuICAgIC8vIFZhbGlkYXRlIHRoYXQgd2UgYXJlIGluIHRoZSByaWdodCBjb250ZXh0IGJ5IGNhbGxpbmcgdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UuXG4gICAgdmFyIGN0eCA9IHVzZUVsZW1lbnRzT3JDdXN0b21DaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIikpO1xuICAgIHVzZUNhcnRFbGVtZW50Q29udGV4dFdpdGhVc2VDYXNlKFwibW91bnRzIDxcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiPlwiKSwgJ2N1c3RvbUNoZWNrb3V0U2RrJyBpbiBjdHgpO1xuICAgIHZhciBpZCA9IHByb3BzLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEVsZW1lbnQgPSBpc1NlcnZlciA/IFNlcnZlckVsZW1lbnQgOiBDbGllbnRFbGVtZW50O1xuICBFbGVtZW50LnByb3BUeXBlcyA9IHtcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25SZWFkeTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Fc2NhcGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZEVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRlclN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbk5ldHdvcmtzQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoZWNrb3V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxpbmVJdGVtQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ29uZmlybTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DYW5jZWw6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNoaXBwaW5nUmF0ZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb3B0aW9uczogUHJvcFR5cGVzLm9iamVjdFxuICB9O1xuICBFbGVtZW50LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIEVsZW1lbnQuX19lbGVtZW50VHlwZSA9IHR5cGU7XG4gIHJldHVybiBFbGVtZW50O1xufTtcblxudmFyIGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBFbWJlZGRlZENoZWNrb3V0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRW1iZWRkZWRDaGVja291dENvbnRleHQuZGlzcGxheU5hbWUgPSAnRW1iZWRkZWRDaGVja291dFByb3ZpZGVyQ29udGV4dCc7XG52YXIgdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQgPSBmdW5jdGlvbiB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCgpIHtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRW1iZWRkZWRDaGVja291dENvbnRleHQpO1xuXG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8RW1iZWRkZWRDaGVja291dD4gbXVzdCBiZSB1c2VkIHdpdGhpbiA8RW1iZWRkZWRDaGVja291dFByb3ZpZGVyPicpO1xuICB9XG5cbiAgcmV0dXJuIGN0eDtcbn07XG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXJgLiBXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBsb2FkU3RyaXBlYCB1dGlsaXR5IGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYC4gU2VlIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm9wcy1zdHJpcGUgZm9yIGRldGFpbHMuJztcbnZhciBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgPSBmdW5jdGlvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCwgSU5WQUxJRF9TVFJJUEVfRVJST1IpO1xuICB9LCBbcmF3U3RyaXBlUHJvcF0pO1xuICB2YXIgZW1iZWRkZWRDaGVja291dFByb21pc2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBsb2FkZWRTdHJpcGUgPSBSZWFjdC51c2VSZWYobnVsbCk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBlbWJlZGRlZENoZWNrb3V0OiBudWxsXG4gIH0pLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBjdHggPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0Q29udGV4dCA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEb24ndCBzdXBwb3J0IGFueSBjdHggdXBkYXRlcyBvbmNlIGVtYmVkZGVkQ2hlY2tvdXQgb3Igc3RyaXBlIGlzIHNldC5cbiAgICBpZiAobG9hZGVkU3RyaXBlLmN1cnJlbnQgfHwgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dCA9IGZ1bmN0aW9uIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHN0cmlwZSkge1xuICAgICAgaWYgKGxvYWRlZFN0cmlwZS5jdXJyZW50IHx8IGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGxvYWRlZFN0cmlwZS5jdXJyZW50ID0gc3RyaXBlO1xuICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCA9IGxvYWRlZFN0cmlwZS5jdXJyZW50LmluaXRFbWJlZGRlZENoZWNrb3V0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGVtYmVkZGVkQ2hlY2tvdXQpIHtcbiAgICAgICAgc2V0Q29udGV4dCh7XG4gICAgICAgICAgZW1iZWRkZWRDaGVja291dDogZW1iZWRkZWRDaGVja291dFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07IC8vIEZvciBhbiBhc3luYyBzdHJpcGVQcm9taXNlLCBzdG9yZSBpdCBvbmNlIHJlc29sdmVkXG5cblxuICAgIGlmIChwYXJzZWQudGFnID09PSAnYXN5bmMnICYmICFsb2FkZWRTdHJpcGUuY3VycmVudCAmJiAob3B0aW9ucy5jbGllbnRTZWNyZXQgfHwgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCkpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlKSB7XG4gICAgICAgICAgc2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQoc3RyaXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgIWxvYWRlZFN0cmlwZS5jdXJyZW50ICYmIChvcHRpb25zLmNsaWVudFNlY3JldCB8fCBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0KSkge1xuICAgICAgLy8gT3IsIGhhbmRsZSBhIHN5bmMgc3RyaXBlIGluc3RhbmNlIGdvaW5nIGZyb20gbnVsbCAtPiBwb3B1bGF0ZWRcbiAgICAgIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHBhcnNlZC5zdHJpcGUpO1xuICAgIH1cbiAgfSwgW3BhcnNlZCwgb3B0aW9ucywgY3R4LCBsb2FkZWRTdHJpcGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjbGVhbnVwIG9uIHVubW91bnRcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSWYgZW1iZWRkZWQgY2hlY2tvdXQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQsIGRlc3Ryb3kgaXQuXG4gICAgICBpZiAoY3R4LmVtYmVkZGVkQ2hlY2tvdXQpIHtcbiAgICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN0eC5lbWJlZGRlZENoZWNrb3V0LmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSBpZiAoZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCkge1xuICAgICAgICAvLyBJZiBlbWJlZGRlZCBjaGVja291dCBpcyBzdGlsbCBpbml0aWFsaXppbmcsIGRlc3Ryb3kgaXQgb25jZVxuICAgICAgICAvLyBpdCdzIGRvbmUuIFRoaXMgY291bGQgYmUgY2F1c2VkIGJ5IHVubW91bnRpbmcgdmVyeSBxdWlja2x5XG4gICAgICAgIC8vIGFmdGVyIG1vdW50aW5nLlxuICAgICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGN0eC5lbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgICAgICBjdHguZW1iZWRkZWRDaGVja291dC5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY3R4LmVtYmVkZGVkQ2hlY2tvdXRdKTsgLy8gQXR0YWNoIHJlYWN0LXN0cmlwZS1qcyB2ZXJzaW9uIHRvIHN0cmlwZS5qcyBpbnN0YW5jZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXJXaXRoU3RyaXBlSnMobG9hZGVkU3RyaXBlKTtcbiAgfSwgW2xvYWRlZFN0cmlwZV0pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gc3RyaXBlIHByb3AuXG4gIC8vIFRoZSBzdHJpcGUgcHJvcCB2YWx1ZSBjYW4gb25seSBnbyBmcm9tIG51bGwgdG8gbm9uLW51bGwgb25jZSBhbmRcbiAgLy8gY2FuJ3QgYmUgY2hhbmdlZCBhZnRlciB0aGF0LlxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gb3B0aW9ucy5cblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldk9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IHVuc2V0IG9wdGlvbnMgYWZ0ZXIgc2V0dGluZyB0aGVtLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNsaWVudFNlY3JldCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHByb3BzIHBhc3NlZCB0byBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBtdXN0IHByb3ZpZGUgb25lIG9mIGVpdGhlciBgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldGAgb3IgYG9wdGlvbnMuY2xpZW50U2VjcmV0YC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMuY2xpZW50U2VjcmV0ICE9IG51bGwgJiYgb3B0aW9ucy5jbGllbnRTZWNyZXQgIT09IHByZXZPcHRpb25zLmNsaWVudFNlY3JldCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBjbGllbnQgc2VjcmV0IGFmdGVyIHNldHRpbmcgaXQuIFVubW91bnQgYW5kIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQgIT0gbnVsbCAmJiBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0ICE9PSBwcmV2T3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIGZldGNoQ2xpZW50U2VjcmV0IGFmdGVyIHNldHRpbmcgaXQuIFVubW91bnQgYW5kIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMub25Db21wbGV0ZSAhPSBudWxsICYmIG9wdGlvbnMub25Db21wbGV0ZSAhPT0gcHJldk9wdGlvbnMub25Db21wbGV0ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvbkNvbXBsZXRlIG9wdGlvbiBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZPcHRpb25zLCBvcHRpb25zXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbWJlZGRlZENoZWNrb3V0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHhcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxudmFyIEVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50ID0gZnVuY3Rpb24gRW1iZWRkZWRDaGVja291dENsaWVudEVsZW1lbnQoX3JlZikge1xuICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWU7XG5cbiAgdmFyIF91c2VFbWJlZGRlZENoZWNrb3V0QyA9IHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KCksXG4gICAgICBlbWJlZGRlZENoZWNrb3V0ID0gX3VzZUVtYmVkZGVkQ2hlY2tvdXRDLmVtYmVkZGVkQ2hlY2tvdXQ7XG5cbiAgdmFyIGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHZhciBkb21Ob2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNNb3VudGVkLmN1cnJlbnQgJiYgZW1iZWRkZWRDaGVja291dCAmJiBkb21Ob2RlLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGVtYmVkZGVkQ2hlY2tvdXQubW91bnQoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9IC8vIENsZWFuIHVwIG9uIHVubW91bnRcblxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCAmJiBlbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZW1iZWRkZWRDaGVja291dC51bm1vdW50KCk7XG4gICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgLy8gUGFyZW50IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBiZWZvcmUgY2hpbGQgZWZmZWN0cywgc29cbiAgICAgICAgICAvLyBpbiBjYXNlcyB3aGVyZSBib3RoIHRoZSBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgYW5kXG4gICAgICAgICAgLy8gdGhlIEVtYmVkZGVkQ2hlY2tvdXQgY29tcG9uZW50IGFyZSByZW1vdmVkIGF0IHRoZSBzYW1lXG4gICAgICAgICAgLy8gdGltZSwgdGhlIGVtYmVkZGVkQ2hlY2tvdXQgaW5zdGFuY2Ugd2lsbCBiZSBkZXN0cm95ZWQsXG4gICAgICAgICAgLy8gd2hpY2ggY2F1c2VzIGFuIGVycm9yIHdoZW4gY2FsbGluZyB1bm1vdW50LlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VtYmVkZGVkQ2hlY2tvdXRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGRvbU5vZGUsXG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0pO1xufTsgLy8gT25seSByZW5kZXIgdGhlIHdyYXBwZXIgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5cblxudmFyIEVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50ID0gZnVuY3Rpb24gRW1iZWRkZWRDaGVja291dFNlcnZlckVsZW1lbnQoX3JlZjIpIHtcbiAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWU7XG4gIC8vIFZhbGlkYXRlIHRoYXQgd2UgYXJlIGluIHRoZSByaWdodCBjb250ZXh0IGJ5IGNhbGxpbmcgdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQuXG4gIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgaWQ6IGlkLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0pO1xufTtcblxudmFyIEVtYmVkZGVkQ2hlY2tvdXQgPSBpc1NlcnZlciA/IEVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50IDogRW1iZWRkZWRDaGVja291dENsaWVudEVsZW1lbnQ7XG5cbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I3VzZXN0cmlwZS1ob29rXG4gKi9cblxudmFyIHVzZVN0cmlwZSA9IGZ1bmN0aW9uIHVzZVN0cmlwZSgpIHtcbiAgdmFyIF91c2VFbGVtZW50c09yQ3VzdG9tQyA9IHVzZUVsZW1lbnRzT3JDdXN0b21DaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSgnY2FsbHMgdXNlU3RyaXBlKCknKSxcbiAgICAgIHN0cmlwZSA9IF91c2VFbGVtZW50c09yQ3VzdG9tQy5zdHJpcGU7XG5cbiAgcmV0dXJuIHN0cmlwZTtcbn07XG5cbi8qKlxuICogUmVxdWlyZXMgYmV0YSBhY2Nlc3M6XG4gKiBDb250YWN0IFtTdHJpcGUgc3VwcG9ydF0oaHR0cHM6Ly9zdXBwb3J0LnN0cmlwZS5jb20vKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEF1QmFua0FjY291bnRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnYXVCYW5rQWNjb3VudCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZE51bWJlckVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkTnVtYmVyJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRFeHBpcnlFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZEV4cGlyeScsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkQ3ZjRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmRDdmMnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgRnB4QmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdmcHhCYW5rJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEliYW5FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnaWJhbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBJZGVhbEJhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnaWRlYWxCYW5rJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIFAyNEJhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncDI0QmFuaycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBFcHNCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2Vwc0JhbmsnLCBpc1NlcnZlcik7XG52YXIgUGF5bWVudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwYXltZW50JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEV4cHJlc3NDaGVja291dEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdleHByZXNzQ2hlY2tvdXQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudFJlcXVlc3RCdXR0b24nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2xpbmtBdXRoZW50aWNhdGlvbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FkZHJlc3MnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBVc2UgYEFkZHJlc3NFbGVtZW50YCBpbnN0ZWFkLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3NoaXBwaW5nQWRkcmVzcycsIGlzU2VydmVyKTtcbi8qKlxuICogUmVxdWlyZXMgYmV0YSBhY2Nlc3M6XG4gKiBDb250YWN0IFtTdHJpcGUgc3VwcG9ydF0oaHR0cHM6Ly9zdXBwb3J0LnN0cmlwZS5jb20vKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9lbGVtZW50cy9jYXJ0LWVsZW1lbnRcbiAqL1xuXG52YXIgQ2FydEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJ0JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIFBheW1lbnRNZXRob2RNZXNzYWdpbmdFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudE1ldGhvZE1lc3NhZ2luZycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZmZpcm1NZXNzYWdlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FmZmlybU1lc3NhZ2UnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQWZ0ZXJwYXlDbGVhcnBheU1lc3NhZ2VFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnYWZ0ZXJwYXlDbGVhcnBheU1lc3NhZ2UnLCBpc1NlcnZlcik7XG5cbmV4cG9ydCB7IEFkZHJlc3NFbGVtZW50LCBBZmZpcm1NZXNzYWdlRWxlbWVudCwgQWZ0ZXJwYXlDbGVhcnBheU1lc3NhZ2VFbGVtZW50LCBBdUJhbmtBY2NvdW50RWxlbWVudCwgQ2FyZEN2Y0VsZW1lbnQsIENhcmRFbGVtZW50LCBDYXJkRXhwaXJ5RWxlbWVudCwgQ2FyZE51bWJlckVsZW1lbnQsIENhcnRFbGVtZW50LCBDdXN0b21DaGVja291dFByb3ZpZGVyLCBFbGVtZW50cywgRWxlbWVudHNDb25zdW1lciwgRW1iZWRkZWRDaGVja291dCwgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyLCBFcHNCYW5rRWxlbWVudCwgRXhwcmVzc0NoZWNrb3V0RWxlbWVudCwgRnB4QmFua0VsZW1lbnQsIEliYW5FbGVtZW50LCBJZGVhbEJhbmtFbGVtZW50LCBMaW5rQXV0aGVudGljYXRpb25FbGVtZW50LCBQMjRCYW5rRWxlbWVudCwgUGF5bWVudEVsZW1lbnQsIFBheW1lbnRNZXRob2RNZXNzYWdpbmdFbGVtZW50LCBQYXltZW50UmVxdWVzdEJ1dHRvbkVsZW1lbnQsIFNoaXBwaW5nQWRkcmVzc0VsZW1lbnQsIHVzZUNhcnRFbGVtZW50LCB1c2VDYXJ0RWxlbWVudFN0YXRlLCB1c2VDdXN0b21DaGVja291dCwgdXNlRWxlbWVudHMsIHVzZVN0cmlwZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHJvcFR5cGVzIiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiX2kiLCJfYXJyIiwiX24iLCJfZCIsIl9zIiwiX2UiLCJuZXh0IiwiZG9uZSIsImVyciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwibGVuIiwiYXJyMiIsIlR5cGVFcnJvciIsInVzZVByZXZpb3VzIiwicmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImlzVW5rbm93bk9iamVjdCIsInJhdyIsImlzUHJvbWlzZSIsInRoZW4iLCJpc1N0cmlwZSIsImVsZW1lbnRzIiwiY3JlYXRlVG9rZW4iLCJjcmVhdGVQYXltZW50TWV0aG9kIiwiY29uZmlybUNhcmRQYXltZW50IiwiUExBSU5fT0JKRUNUX1NUUiIsImlzRXF1YWwiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0QXJyYXkiLCJyaWdodEFycmF5IiwibGVmdFBsYWluT2JqZWN0IiwicmlnaHRQbGFpbk9iamVjdCIsImxlZnRLZXlzIiwicmlnaHRLZXlzIiwia2V5U2V0IiwiYWxsS2V5cyIsImwiLCJyIiwicHJlZCIsImV2ZXJ5IiwiZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyIsIm9wdGlvbnMiLCJwcmV2T3B0aW9ucyIsImltbXV0YWJsZUtleXMiLCJyZWR1Y2UiLCJuZXdPcHRpb25zIiwiaXNVcGRhdGVkIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImNvbmNhdCIsIklOVkFMSURfU1RSSVBFX0VSUk9SJDIiLCJ2YWxpZGF0ZVN0cmlwZSIsIm1heWJlU3RyaXBlIiwiZXJyb3JNc2ciLCJ1bmRlZmluZWQiLCJFcnJvciIsInBhcnNlU3RyaXBlUHJvcCIsInRhZyIsInN0cmlwZVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3VsdCIsInN0cmlwZSIsInJlZ2lzdGVyV2l0aFN0cmlwZUpzIiwiX3JlZ2lzdGVyV3JhcHBlciIsInJlZ2lzdGVyQXBwSW5mbyIsInZlcnNpb24iLCJ1cmwiLCJFbGVtZW50c0NvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZGlzcGxheU5hbWUiLCJwYXJzZUVsZW1lbnRzQ29udGV4dCIsImN0eCIsInVzZUNhc2UiLCJDYXJ0RWxlbWVudENvbnRleHQiLCJwYXJzZUNhcnRFbGVtZW50Q29udGV4dCIsIkVsZW1lbnRzIiwiX3JlZiIsInJhd1N0cmlwZVByb3AiLCJjaGlsZHJlbiIsInBhcnNlZCIsInVzZU1lbW8iLCJfUmVhY3QkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl9SZWFjdCR1c2VTdGF0ZTIiLCJjYXJ0Iiwic2V0Q2FydCIsIl9SZWFjdCR1c2VTdGF0ZTMiLCJfUmVhY3QkdXNlU3RhdGU0IiwiY2FydFN0YXRlIiwic2V0Q2FydFN0YXRlIiwiX1JlYWN0JHVzZVN0YXRlNSIsIl9SZWFjdCR1c2VTdGF0ZTYiLCJzZXRDb250ZXh0IiwiaXNNb3VudGVkIiwic2FmZVNldENvbnRleHQiLCJwcmV2U3RyaXBlIiwidXBkYXRlcyIsInVwZGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInByb3BUeXBlcyIsImFueSIsInVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlIiwidXNlQ2FzZU1lc3NhZ2UiLCJ1c2VDb250ZXh0IiwiRFVNTVlfQ0FSVF9FTEVNRU5UX0NPTlRFWFQiLCJ1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZSIsImlzSW5DdXN0b21DaGVja291dCIsInVzZUVsZW1lbnRzIiwiX3VzZUVsZW1lbnRzQ29udGV4dFdpIiwidXNlQ2FydEVsZW1lbnQiLCJfdXNlQ2FydEVsZW1lbnRDb250ZXgiLCJ1c2VDYXJ0RWxlbWVudFN0YXRlIiwiX3VzZUNhcnRFbGVtZW50Q29udGV4MiIsIkVsZW1lbnRzQ29uc3VtZXIiLCJfcmVmMiIsImZ1bmMiLCJpc1JlcXVpcmVkIiwidXNlQXR0YWNoRXZlbnQiLCJlbGVtZW50IiwiZXZlbnQiLCJjYiIsImNiRGVmaW5lZCIsImNiUmVmIiwiZGVjb3JhdGVkQ2IiLCJvbiIsIm9mZiIsIl9leGNsdWRlZCIsIkN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dCIsInBhcnNlQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0IiwiQ3VzdG9tQ2hlY2tvdXRDb250ZXh0IiwiZXh0cmFjdEN1c3RvbUNoZWNrb3V0Q29udGV4dFZhbHVlIiwiY3VzdG9tQ2hlY2tvdXRTZGsiLCJzZXNzaW9uU3RhdGUiLCJzZXNzaW9uIiwiYWN0aW9ucyIsIklOVkFMSURfU1RSSVBFX0VSUk9SJDEiLCJDdXN0b21DaGVja291dFByb3ZpZGVyIiwic2V0U2Vzc2lvbiIsImluaXRDdXN0b21DaGVja291dENhbGxlZFJlZiIsImluaXRDdXN0b21DaGVja291dCIsIl9wcmV2T3B0aW9ucyRlbGVtZW50cyIsIl9vcHRpb25zJGVsZW1lbnRzT3B0aSIsImNsaWVudFNlY3JldCIsInByZXZpb3VzQXBwZWFyYW5jZSIsImVsZW1lbnRzT3B0aW9ucyIsImFwcGVhcmFuY2UiLCJjdXJyZW50QXBwZWFyYW5jZSIsImNoYW5nZUFwcGVhcmFuY2UiLCJjdXN0b21DaGVja291dENvbnRleHRWYWx1ZSIsInNoYXBlIiwic3RyaW5nIiwidXNlQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UiLCJ1c2VDYXNlU3RyaW5nIiwidXNlRWxlbWVudHNPckN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlIiwiY3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0IiwiZWxlbWVudHNDb250ZXh0IiwidXNlQ3VzdG9tQ2hlY2tvdXQiLCJjYXBpdGFsaXplZCIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiY3JlYXRlRWxlbWVudENvbXBvbmVudCIsInR5cGUiLCJpc1NlcnZlciIsIkNsaWVudEVsZW1lbnQiLCJpZCIsImNsYXNzTmFtZSIsIl9yZWYkb3B0aW9ucyIsIm9uQmx1ciIsIm9uRm9jdXMiLCJvblJlYWR5Iiwib25DaGFuZ2UiLCJvbkVzY2FwZSIsIm9uQ2xpY2siLCJvbkxvYWRFcnJvciIsIm9uTG9hZGVyU3RhcnQiLCJvbk5ldHdvcmtzQ2hhbmdlIiwib25DaGVja291dCIsIm9uTGluZUl0ZW1DbGljayIsIm9uQ29uZmlybSIsIm9uQ2FuY2VsIiwib25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UiLCJvblNoaXBwaW5nUmF0ZUNoYW5nZSIsInNldEVsZW1lbnQiLCJlbGVtZW50UmVmIiwiZG9tTm9kZSIsInJlYWR5Q2FsbGJhY2siLCJjaGFuZ2VDYWxsYmFjayIsImNoZWNrb3V0Q2FsbGJhY2siLCJ1c2VMYXlvdXRFZmZlY3QiLCJuZXdFbGVtZW50IiwiY3JlYXRlIiwibW91bnQiLCJkZXN0cm95IiwiZXJyb3IiLCJTZXJ2ZXJFbGVtZW50IiwicHJvcHMiLCJFbGVtZW50IiwiX19lbGVtZW50VHlwZSIsIkVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0IiwidXNlRW1iZWRkZWRDaGVja291dENvbnRleHQiLCJJTlZBTElEX1NUUklQRV9FUlJPUiIsIkVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciIsImVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlIiwibG9hZGVkU3RyaXBlIiwiZW1iZWRkZWRDaGVja291dCIsInNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0IiwiaW5pdEVtYmVkZGVkQ2hlY2tvdXQiLCJmZXRjaENsaWVudFNlY3JldCIsIm9uQ29tcGxldGUiLCJFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudCIsIl91c2VFbWJlZGRlZENoZWNrb3V0QyIsInVubW91bnQiLCJlIiwiRW1iZWRkZWRDaGVja291dFNlcnZlckVsZW1lbnQiLCJFbWJlZGRlZENoZWNrb3V0IiwidXNlU3RyaXBlIiwiX3VzZUVsZW1lbnRzT3JDdXN0b21DIiwiQXVCYW5rQWNjb3VudEVsZW1lbnQiLCJDYXJkRWxlbWVudCIsIkNhcmROdW1iZXJFbGVtZW50IiwiQ2FyZEV4cGlyeUVsZW1lbnQiLCJDYXJkQ3ZjRWxlbWVudCIsIkZweEJhbmtFbGVtZW50IiwiSWJhbkVsZW1lbnQiLCJJZGVhbEJhbmtFbGVtZW50IiwiUDI0QmFua0VsZW1lbnQiLCJFcHNCYW5rRWxlbWVudCIsIlBheW1lbnRFbGVtZW50IiwiRXhwcmVzc0NoZWNrb3V0RWxlbWVudCIsIlBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCIsIkxpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQiLCJBZGRyZXNzRWxlbWVudCIsIlNoaXBwaW5nQWRkcmVzc0VsZW1lbnQiLCJDYXJ0RWxlbWVudCIsIlBheW1lbnRNZXRob2RNZXNzYWdpbmdFbGVtZW50IiwiQWZmaXJtTWVzc2FnZUVsZW1lbnQiLCJBZnRlcnBheUNsZWFycGF5TWVzc2FnZUVsZW1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/stripe.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/stripe.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadStripe: () => (/* binding */ loadStripe)\n/* harmony export */ });\nvar V3_URL = \"https://js.stripe.com/v3\";\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = \"loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used\";\nvar findScript = function findScript() {\n    var scripts = document.querySelectorAll('script[src^=\"'.concat(V3_URL, '\"]'));\n    for(var i = 0; i < scripts.length; i++){\n        var script = scripts[i];\n        if (!V3_URL_REGEX.test(script.src)) {\n            continue;\n        }\n        return script;\n    }\n    return null;\n};\nvar injectScript = function injectScript(params) {\n    var queryString = params && !params.advancedFraudSignals ? \"?advancedFraudSignals=false\" : \"\";\n    var script = document.createElement(\"script\");\n    script.src = \"\".concat(V3_URL).concat(queryString);\n    var headOrBody = document.head || document.body;\n    if (!headOrBody) {\n        throw new Error(\"Expected document.body not to be null. Stripe.js requires a <body> element.\");\n    }\n    headOrBody.appendChild(script);\n    return script;\n};\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n    if (!stripe || !stripe._registerWrapper) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"stripe-js\",\n        version: \"3.0.10\",\n        startTime: startTime\n    });\n};\nvar stripePromise = null;\nvar onErrorListener = null;\nvar onLoadListener = null;\nvar onError = function onError(reject) {\n    return function() {\n        reject(new Error(\"Failed to load Stripe.js\"));\n    };\n};\nvar onLoad = function onLoad(resolve, reject) {\n    return function() {\n        if (window.Stripe) {\n            resolve(window.Stripe);\n        } else {\n            reject(new Error(\"Stripe.js not available\"));\n        }\n    };\n};\nvar loadScript = function loadScript(params) {\n    // Ensure that we only attempt to load Stripe.js at most once\n    if (stripePromise !== null) {\n        return stripePromise;\n    }\n    stripePromise = new Promise(function(resolve, reject) {\n        if (true) {\n            // Resolve to null when imported server side. This makes the module\n            // safe to import in an isomorphic code base.\n            resolve(null);\n            return;\n        }\n        if (window.Stripe && params) {\n            console.warn(EXISTING_SCRIPT_MESSAGE);\n        }\n        if (window.Stripe) {\n            resolve(window.Stripe);\n            return;\n        }\n        try {\n            var script = findScript();\n            if (script && params) {\n                console.warn(EXISTING_SCRIPT_MESSAGE);\n            } else if (!script) {\n                script = injectScript(params);\n            } else if (script && onLoadListener !== null && onErrorListener !== null) {\n                var _script$parentNode;\n                // remove event listeners\n                script.removeEventListener(\"load\", onLoadListener);\n                script.removeEventListener(\"error\", onErrorListener); // if script exists, but we are reloading due to an error,\n                // reload script to trigger 'load' event\n                (_script$parentNode = script.parentNode) === null || _script$parentNode === void 0 ? void 0 : _script$parentNode.removeChild(script);\n                script = injectScript(params);\n            }\n            onLoadListener = onLoad(resolve, reject);\n            onErrorListener = onError(reject);\n            script.addEventListener(\"load\", onLoadListener);\n            script.addEventListener(\"error\", onErrorListener);\n        } catch (error) {\n            reject(error);\n            return;\n        }\n    }); // Resets stripePromise on error\n    return stripePromise[\"catch\"](function(error) {\n        stripePromise = null;\n        return Promise.reject(error);\n    });\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n    if (maybeStripe === null) {\n        return null;\n    }\n    var stripe = maybeStripe.apply(undefined, args);\n    registerWrapper(stripe, startTime);\n    return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar stripePromise$1;\nvar loadCalled = false;\nvar getStripePromise = function getStripePromise() {\n    if (stripePromise$1) {\n        return stripePromise$1;\n    }\n    stripePromise$1 = loadScript(null)[\"catch\"](function(error) {\n        // clear cache on error\n        stripePromise$1 = null;\n        return Promise.reject(error);\n    });\n    return stripePromise$1;\n}; // Execute our own script injection after a tick to give users time to do their\n// own script injection.\nPromise.resolve().then(function() {\n    return getStripePromise();\n})[\"catch\"](function(error) {\n    if (!loadCalled) {\n        console.warn(error);\n    }\n});\nvar loadStripe = function loadStripe() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    loadCalled = true;\n    var startTime = Date.now(); // if previous attempts are unsuccessful, will re-load script\n    return getStripePromise().then(function(maybeStripe) {\n        return initStripe(maybeStripe, args, startTime);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9zdHJpcGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxTQUFTO0FBQ2IsSUFBSUMsZUFBZTtBQUNuQixJQUFJQywwQkFBMEI7QUFDOUIsSUFBSUMsYUFBYSxTQUFTQTtJQUN4QixJQUFJQyxVQUFVQyxTQUFTQyxnQkFBZ0IsQ0FBQyxnQkFBaUJDLE1BQU0sQ0FBQ1AsUUFBUTtJQUV4RSxJQUFLLElBQUlRLElBQUksR0FBR0EsSUFBSUosUUFBUUssTUFBTSxFQUFFRCxJQUFLO1FBQ3ZDLElBQUlFLFNBQVNOLE9BQU8sQ0FBQ0ksRUFBRTtRQUV2QixJQUFJLENBQUNQLGFBQWFVLElBQUksQ0FBQ0QsT0FBT0UsR0FBRyxHQUFHO1lBQ2xDO1FBQ0Y7UUFFQSxPQUFPRjtJQUNUO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSUcsZUFBZSxTQUFTQSxhQUFhQyxNQUFNO0lBQzdDLElBQUlDLGNBQWNELFVBQVUsQ0FBQ0EsT0FBT0Usb0JBQW9CLEdBQUcsZ0NBQWdDO0lBQzNGLElBQUlOLFNBQVNMLFNBQVNZLGFBQWEsQ0FBQztJQUNwQ1AsT0FBT0UsR0FBRyxHQUFHLEdBQUdMLE1BQU0sQ0FBQ1AsUUFBUU8sTUFBTSxDQUFDUTtJQUN0QyxJQUFJRyxhQUFhYixTQUFTYyxJQUFJLElBQUlkLFNBQVNlLElBQUk7SUFFL0MsSUFBSSxDQUFDRixZQUFZO1FBQ2YsTUFBTSxJQUFJRyxNQUFNO0lBQ2xCO0lBRUFILFdBQVdJLFdBQVcsQ0FBQ1o7SUFDdkIsT0FBT0E7QUFDVDtBQUVBLElBQUlhLGtCQUFrQixTQUFTQSxnQkFBZ0JDLE1BQU0sRUFBRUMsU0FBUztJQUM5RCxJQUFJLENBQUNELFVBQVUsQ0FBQ0EsT0FBT0UsZ0JBQWdCLEVBQUU7UUFDdkM7SUFDRjtJQUVBRixPQUFPRSxnQkFBZ0IsQ0FBQztRQUN0QkMsTUFBTTtRQUNOQyxTQUFTO1FBQ1RILFdBQVdBO0lBQ2I7QUFDRjtBQUVB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QUFDLFFBQVEsQ0FBQyxTQUFVUixLQUFLO0lBQ3pCLElBQUksQ0FBQ08sWUFBWTtRQUNmZCxRQUFRQyxJQUFJLENBQUNNO0lBQ2Y7QUFDRjtBQUNBLElBQUlVLGFBQWEsU0FBU0E7SUFDeEIsSUFBSyxJQUFJQyxPQUFPQyxVQUFVbEQsTUFBTSxFQUFFeUMsT0FBTyxJQUFJVSxNQUFNRixPQUFPRyxPQUFPLEdBQUdBLE9BQU9ILE1BQU1HLE9BQVE7UUFDdkZYLElBQUksQ0FBQ1csS0FBSyxHQUFHRixTQUFTLENBQUNFLEtBQUs7SUFDOUI7SUFFQVAsYUFBYTtJQUNiLElBQUk3QixZQUFZcUMsS0FBS0MsR0FBRyxJQUFJLDZEQUE2RDtJQUV6RixPQUFPUixtQkFBbUJDLElBQUksQ0FBQyxTQUFVUCxXQUFXO1FBQ2xELE9BQU9ELFdBQVdDLGFBQWFDLE1BQU16QjtJQUN2QztBQUNGO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHVtcGtpbi1zdG9yZS8uL25vZGVfbW9kdWxlcy9Ac3RyaXBlL3N0cmlwZS1qcy9kaXN0L3N0cmlwZS5tanM/ZGI5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVjNfVVJMID0gJ2h0dHBzOi8vanMuc3RyaXBlLmNvbS92Myc7XG52YXIgVjNfVVJMX1JFR0VYID0gL15odHRwczpcXC9cXC9qc1xcLnN0cmlwZVxcLmNvbVxcL3YzXFwvPyhcXD8uKik/JC87XG52YXIgRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UgPSAnbG9hZFN0cmlwZS5zZXRMb2FkUGFyYW1ldGVycyB3YXMgY2FsbGVkIGJ1dCBhbiBleGlzdGluZyBTdHJpcGUuanMgc2NyaXB0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBkb2N1bWVudDsgZXhpc3Rpbmcgc2NyaXB0IHBhcmFtZXRlcnMgd2lsbCBiZSB1c2VkJztcbnZhciBmaW5kU2NyaXB0ID0gZnVuY3Rpb24gZmluZFNjcmlwdCgpIHtcbiAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0W3NyY149XFxcIlwiLmNvbmNhdChWM19VUkwsIFwiXFxcIl1cIikpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW2ldO1xuXG4gICAgaWYgKCFWM19VUkxfUkVHRVgudGVzdChzY3JpcHQuc3JjKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcmlwdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIGluamVjdFNjcmlwdCA9IGZ1bmN0aW9uIGluamVjdFNjcmlwdChwYXJhbXMpIHtcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gcGFyYW1zICYmICFwYXJhbXMuYWR2YW5jZWRGcmF1ZFNpZ25hbHMgPyAnP2FkdmFuY2VkRnJhdWRTaWduYWxzPWZhbHNlJyA6ICcnO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5zcmMgPSBcIlwiLmNvbmNhdChWM19VUkwpLmNvbmNhdChxdWVyeVN0cmluZyk7XG4gIHZhciBoZWFkT3JCb2R5ID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5O1xuXG4gIGlmICghaGVhZE9yQm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZG9jdW1lbnQuYm9keSBub3QgdG8gYmUgbnVsbC4gU3RyaXBlLmpzIHJlcXVpcmVzIGEgPGJvZHk+IGVsZW1lbnQuJyk7XG4gIH1cblxuICBoZWFkT3JCb2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG52YXIgcmVnaXN0ZXJXcmFwcGVyID0gZnVuY3Rpb24gcmVnaXN0ZXJXcmFwcGVyKHN0cmlwZSwgc3RhcnRUaW1lKSB7XG4gIGlmICghc3RyaXBlIHx8ICFzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKHtcbiAgICBuYW1lOiAnc3RyaXBlLWpzJyxcbiAgICB2ZXJzaW9uOiBcIjMuMC4xMFwiLFxuICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lXG4gIH0pO1xufTtcblxudmFyIHN0cmlwZVByb21pc2UgPSBudWxsO1xudmFyIG9uRXJyb3JMaXN0ZW5lciA9IG51bGw7XG52YXIgb25Mb2FkTGlzdGVuZXIgPSBudWxsO1xuXG52YXIgb25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IocmVqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgU3RyaXBlLmpzJykpO1xuICB9O1xufTtcblxudmFyIG9uTG9hZCA9IGZ1bmN0aW9uIG9uTG9hZChyZXNvbHZlLCByZWplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod2luZG93LlN0cmlwZSkge1xuICAgICAgcmVzb2x2ZSh3aW5kb3cuU3RyaXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcignU3RyaXBlLmpzIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGxvYWRTY3JpcHQgPSBmdW5jdGlvbiBsb2FkU2NyaXB0KHBhcmFtcykge1xuICAvLyBFbnN1cmUgdGhhdCB3ZSBvbmx5IGF0dGVtcHQgdG8gbG9hZCBTdHJpcGUuanMgYXQgbW9zdCBvbmNlXG4gIGlmIChzdHJpcGVQcm9taXNlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0cmlwZVByb21pc2U7XG4gIH1cblxuICBzdHJpcGVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXNvbHZlIHRvIG51bGwgd2hlbiBpbXBvcnRlZCBzZXJ2ZXIgc2lkZS4gVGhpcyBtYWtlcyB0aGUgbW9kdWxlXG4gICAgICAvLyBzYWZlIHRvIGltcG9ydCBpbiBhbiBpc29tb3JwaGljIGNvZGUgYmFzZS5cbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5TdHJpcGUgJiYgcGFyYW1zKSB7XG4gICAgICBjb25zb2xlLndhcm4oRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UpO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuU3RyaXBlKSB7XG4gICAgICByZXNvbHZlKHdpbmRvdy5TdHJpcGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgc2NyaXB0ID0gZmluZFNjcmlwdCgpO1xuXG4gICAgICBpZiAoc2NyaXB0ICYmIHBhcmFtcykge1xuICAgICAgICBjb25zb2xlLndhcm4oRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UpO1xuICAgICAgfSBlbHNlIGlmICghc2NyaXB0KSB7XG4gICAgICAgIHNjcmlwdCA9IGluamVjdFNjcmlwdChwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChzY3JpcHQgJiYgb25Mb2FkTGlzdGVuZXIgIT09IG51bGwgJiYgb25FcnJvckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfc2NyaXB0JHBhcmVudE5vZGU7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZExpc3RlbmVyKTtcbiAgICAgICAgc2NyaXB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvckxpc3RlbmVyKTsgLy8gaWYgc2NyaXB0IGV4aXN0cywgYnV0IHdlIGFyZSByZWxvYWRpbmcgZHVlIHRvIGFuIGVycm9yLFxuICAgICAgICAvLyByZWxvYWQgc2NyaXB0IHRvIHRyaWdnZXIgJ2xvYWQnIGV2ZW50XG5cbiAgICAgICAgKF9zY3JpcHQkcGFyZW50Tm9kZSA9IHNjcmlwdC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfc2NyaXB0JHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY3JpcHQkcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICBzY3JpcHQgPSBpbmplY3RTY3JpcHQocGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgb25Mb2FkTGlzdGVuZXIgPSBvbkxvYWQocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIG9uRXJyb3JMaXN0ZW5lciA9IG9uRXJyb3IocmVqZWN0KTtcbiAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkTGlzdGVuZXIpO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvckxpc3RlbmVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pOyAvLyBSZXNldHMgc3RyaXBlUHJvbWlzZSBvbiBlcnJvclxuXG4gIHJldHVybiBzdHJpcGVQcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgc3RyaXBlUHJvbWlzZSA9IG51bGw7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfSk7XG59O1xudmFyIGluaXRTdHJpcGUgPSBmdW5jdGlvbiBpbml0U3RyaXBlKG1heWJlU3RyaXBlLCBhcmdzLCBzdGFydFRpbWUpIHtcbiAgaWYgKG1heWJlU3RyaXBlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc3RyaXBlID0gbWF5YmVTdHJpcGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgcmVnaXN0ZXJXcmFwcGVyKHN0cmlwZSwgc3RhcnRUaW1lKTtcbiAgcmV0dXJuIHN0cmlwZTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5cbnZhciBzdHJpcGVQcm9taXNlJDE7XG52YXIgbG9hZENhbGxlZCA9IGZhbHNlO1xuXG52YXIgZ2V0U3RyaXBlUHJvbWlzZSA9IGZ1bmN0aW9uIGdldFN0cmlwZVByb21pc2UoKSB7XG4gIGlmIChzdHJpcGVQcm9taXNlJDEpIHtcbiAgICByZXR1cm4gc3RyaXBlUHJvbWlzZSQxO1xuICB9XG5cbiAgc3RyaXBlUHJvbWlzZSQxID0gbG9hZFNjcmlwdChudWxsKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIC8vIGNsZWFyIGNhY2hlIG9uIGVycm9yXG4gICAgc3RyaXBlUHJvbWlzZSQxID0gbnVsbDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9KTtcbiAgcmV0dXJuIHN0cmlwZVByb21pc2UkMTtcbn07IC8vIEV4ZWN1dGUgb3VyIG93biBzY3JpcHQgaW5qZWN0aW9uIGFmdGVyIGEgdGljayB0byBnaXZlIHVzZXJzIHRpbWUgdG8gZG8gdGhlaXJcbi8vIG93biBzY3JpcHQgaW5qZWN0aW9uLlxuXG5cblByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZ2V0U3RyaXBlUHJvbWlzZSgpO1xufSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgaWYgKCFsb2FkQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgfVxufSk7XG52YXIgbG9hZFN0cmlwZSA9IGZ1bmN0aW9uIGxvYWRTdHJpcGUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2FkQ2FsbGVkID0gdHJ1ZTtcbiAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7IC8vIGlmIHByZXZpb3VzIGF0dGVtcHRzIGFyZSB1bnN1Y2Nlc3NmdWwsIHdpbGwgcmUtbG9hZCBzY3JpcHRcblxuICByZXR1cm4gZ2V0U3RyaXBlUHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24gKG1heWJlU3RyaXBlKSB7XG4gICAgcmV0dXJuIGluaXRTdHJpcGUobWF5YmVTdHJpcGUsIGFyZ3MsIHN0YXJ0VGltZSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IHsgbG9hZFN0cmlwZSB9O1xuIl0sIm5hbWVzIjpbIlYzX1VSTCIsIlYzX1VSTF9SRUdFWCIsIkVYSVNUSU5HX1NDUklQVF9NRVNTQUdFIiwiZmluZFNjcmlwdCIsInNjcmlwdHMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjb25jYXQiLCJpIiwibGVuZ3RoIiwic2NyaXB0IiwidGVzdCIsInNyYyIsImluamVjdFNjcmlwdCIsInBhcmFtcyIsInF1ZXJ5U3RyaW5nIiwiYWR2YW5jZWRGcmF1ZFNpZ25hbHMiLCJjcmVhdGVFbGVtZW50IiwiaGVhZE9yQm9keSIsImhlYWQiLCJib2R5IiwiRXJyb3IiLCJhcHBlbmRDaGlsZCIsInJlZ2lzdGVyV3JhcHBlciIsInN0cmlwZSIsInN0YXJ0VGltZSIsIl9yZWdpc3RlcldyYXBwZXIiLCJuYW1lIiwidmVyc2lvbiIsInN0cmlwZVByb21pc2UiLCJvbkVycm9yTGlzdGVuZXIiLCJvbkxvYWRMaXN0ZW5lciIsIm9uRXJyb3IiLCJyZWplY3QiLCJvbkxvYWQiLCJyZXNvbHZlIiwid2luZG93IiwiU3RyaXBlIiwibG9hZFNjcmlwdCIsIlByb21pc2UiLCJjb25zb2xlIiwid2FybiIsIl9zY3JpcHQkcGFyZW50Tm9kZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXJyb3IiLCJpbml0U3RyaXBlIiwibWF5YmVTdHJpcGUiLCJhcmdzIiwiYXBwbHkiLCJ1bmRlZmluZWQiLCJzdHJpcGVQcm9taXNlJDEiLCJsb2FkQ2FsbGVkIiwiZ2V0U3RyaXBlUHJvbWlzZSIsInRoZW4iLCJsb2FkU3RyaXBlIiwiX2xlbiIsImFyZ3VtZW50cyIsIkFycmF5IiwiX2tleSIsIkRhdGUiLCJub3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/stripe.mjs\n");

/***/ })

};
;